======================================================================
EXPORT FOLDER APP & DATABASE - NGEVENT.ID (LARAVEL)
Export Date: 2026-01-18T09:25:23.478Z
======================================================================

STRUKTUR LENGKAP FOLDER APP & DATABASE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app/
â”œâ”€â”€ Enums/
â”‚   â”œâ”€â”€ EventStatus.php
â”‚   â”œâ”€â”€ OrderStatus.php
â”‚   â”œâ”€â”€ PaymentStatus.php
â”‚   â”œâ”€â”€ SettlementStatus.php
â”‚   â”œâ”€â”€ TicketType.php
â”‚   â”œâ”€â”€ UserRole.php
â”‚   â””â”€â”€ VoucherType.php
â”œâ”€â”€ Events/
â”‚   â”œâ”€â”€ OrderPaid.php
â”‚   â””â”€â”€ TicketIssued.php
â”œâ”€â”€ Exceptions/
â”‚   â”œâ”€â”€ InsufficientTicketException.php
â”‚   â”œâ”€â”€ PaymentFailedException.php
â”‚   â””â”€â”€ VoucherInvalidException.php
â”œâ”€â”€ Http/
â”‚   â”œâ”€â”€ Admin/ (kosong)
â”‚   â”œâ”€â”€ Controllers/
â”‚   â”‚   â”œâ”€â”€ Admin/
â”‚   â”‚   â”‚   â”œâ”€â”€ CategoryController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ DashboardController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ EventController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ SettlementController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ UserController.php
â”‚   â”‚   â”‚   â””â”€â”€ VoucherController.php
â”‚   â”‚   â”œâ”€â”€ Api/ (kosong)
â”‚   â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ ForgotPasswordController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ ResetPasswordController.php
â”‚   â”‚   â”‚   â””â”€â”€ VerifyEmailController.php
â”‚   â”‚   â”œâ”€â”€ Organizer/
â”‚   â”‚   â”‚   â”œâ”€â”€ AttendeeController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ DashboardController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ EventController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ ProfileController.php
â”‚   â”‚   â”‚   â””â”€â”€ TicketController.php
â”‚   â”‚   â”œâ”€â”€ User/
â”‚   â”‚   â”‚   â”œâ”€â”€ CheckoutController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ EventController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ HomeController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderController.php
â”‚   â”‚   â”‚   â”œâ”€â”€ ProfileController.php
â”‚   â”‚   â”‚   â””â”€â”€ TicketController.php
â”‚   â”‚   â”œâ”€â”€ Webhook/
â”‚   â”‚   â”‚   â””â”€â”€ XenditController.php
â”‚   â”‚   â””â”€â”€ Controller.php
â”‚   â”œâ”€â”€ Middleware/
â”‚   â”‚   â”œâ”€â”€ AdminMiddleware.php
â”‚   â”‚   â”œâ”€â”€ EnsureUserIsAdmin.php
â”‚   â”‚   â”œâ”€â”€ EnsureUserIsOrganizer.php
â”‚   â”‚   â”œâ”€â”€ OrganizerMiddleware.php
â”‚   â”‚   â”œâ”€â”€ ThrottleCheckout.php
â”‚   â”‚   â””â”€â”€ XenditWebhookSignature.php
â”‚   â””â”€â”€ Requests/
â”‚       â”œâ”€â”€ Admin/ (kosong)
â”‚       â”œâ”€â”€ Organizer/ (kosong)
â”‚       â””â”€â”€ User/ (kosong)
â”œâ”€â”€ Jobs/
â”‚   â”œâ”€â”€ ExpireUnpaidOrders.php
â”‚   â”œâ”€â”€ GenerateETicket.php
â”‚   â””â”€â”€ SendOrderConfirmation.php
â”œâ”€â”€ Listeners/
â”‚   â”œâ”€â”€ SendTicketEmail.php
â”‚   â””â”€â”€ UpdateTicketStock.php
â”œâ”€â”€ Mail/ (kosong)
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Category.php
â”‚   â”œâ”€â”€ Event.php
â”‚   â”œâ”€â”€ EventDay.php
â”‚   â”œâ”€â”€ IssuedTicket.php
â”‚   â”œâ”€â”€ Order.php
â”‚   â”œâ”€â”€ OrderItem.php
â”‚   â”œâ”€â”€ Organizer.php
â”‚   â”œâ”€â”€ OrganizerSocialLink.php
â”‚   â”œâ”€â”€ Payment.php
â”‚   â”œâ”€â”€ Subcategory.php
â”‚   â”œâ”€â”€ Ticket.php
â”‚   â”œâ”€â”€ TicketVariant.php
â”‚   â”œâ”€â”€ User.php
â”‚   â”œâ”€â”€ Voucher.php
â”‚   â””â”€â”€ VoucherUsage.php
â”œâ”€â”€ Notifications/ (kosong)
â”œâ”€â”€ Policies/ (kosong)
â”œâ”€â”€ Providers/
â”‚   â”œâ”€â”€ AppServiceProvider.php
â”‚   â””â”€â”€ RouteServiceProvider.php
â”œâ”€â”€ Repositories/
â”‚   â”œâ”€â”€ Contracts/ (kosong)
â”‚   â””â”€â”€ Eloquent/ (kosong)
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Xendit/
â”‚   â”‚   â””â”€â”€ XenditClient.php
â”‚   â”œâ”€â”€ ETicketService.php
â”‚   â”œâ”€â”€ EventService.php
â”‚   â”œâ”€â”€ OrderService.php
â”‚   â”œâ”€â”€ PaymentService.php
â”‚   â”œâ”€â”€ SettlementService.php
â”‚   â”œâ”€â”€ TicketService.php
â”‚   â””â”€â”€ VoucherService.php
â”œâ”€â”€ Traits/
â”‚   â””â”€â”€ HasSlug.php
â””â”€â”€ View/
    â””â”€â”€ Components/
        â”œâ”€â”€ AppLayout.php
        â””â”€â”€ OrganizerLayout.php

database/
â”œâ”€â”€ factories/
â”‚   â””â”€â”€ UserFactory.php
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 0001_01_01_000000_create_users_table.php
â”‚   â”œâ”€â”€ 0001_01_01_000001_create_cache_table.php
â”‚   â”œâ”€â”€ 0001_01_01_000002_create_jobs_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000001_create_organizers_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000002_create_organizer_social_links_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000003_create_categories_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000004_create_subcategories_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000005_create_events_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000006_create_event_subcategory_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000007_create_event_days_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000008_create_tickets_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000009_create_ticket_variants_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000010_create_vouchers_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000011_create_orders_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000012_create_order_items_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000013_create_payments_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000014_create_issued_tickets_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000015_create_voucher_usages_table.php
â”‚   â”œâ”€â”€ 2024_01_01_000016_create_settlements_table.php
â”‚   â””â”€â”€ 2026_01_13_000001_simplify_event_status.php
â””â”€â”€ seeders/
    â”œâ”€â”€ CategorySeeder.php
    â”œâ”€â”€ DatabaseSeeder.php
    â”œâ”€â”€ EventSeeder.php
    â”œâ”€â”€ OrganizerSeeder.php
    â”œâ”€â”€ SubcategorySeeder.php
    â”œâ”€â”€ UserSeeder.php
    â””â”€â”€ VoucherSeeder.php


ðŸ“‚ FOLDER KOSONG:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   app/Http/Admin/ (kosong)
   app/Http/Controllers/Api/ (kosong)
   app/Http/Requests/ (kosong)
   app/Http/Requests/Admin/ (kosong)
   app/Http/Requests/Organizer/ (kosong)
   app/Http/Requests/User/ (kosong)
   app/Mail/ (kosong)
   app/Notifications/ (kosong)
   app/Policies/ (kosong)
   app/Repositories/ (kosong)
   app/Repositories/Contracts/ (kosong)
   app/Repositories/Eloquent/ (kosong)


======================================================================
ISI FILE:
======================================================================

======================================================================
FILE: app/Enums/EventStatus.php (58 lines)
======================================================================
<?php

namespace App\Enums;

enum EventStatus: string
{
    case DRAFT = 'draft';
    case PUBLISHED = 'published';
    case COMPLETED = 'completed';

    public function label(): string
    {
        return match ($this) {
            self::DRAFT => 'Draft',
            self::PUBLISHED => 'Dipublikasi',
            self::COMPLETED => 'Selesai',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::DRAFT => 'gray',
            self::PUBLISHED => 'green',
            self::COMPLETED => 'blue',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::DRAFT => 'pencil',
            self::PUBLISHED => 'globe',
            self::COMPLETED => 'check-circle',
        };
    }

    public function canEdit(): bool
    {
        return $this === self::DRAFT;
    }

    public function canDelete(): bool
    {
        return $this === self::DRAFT;
    }

    public function canPublish(): bool
    {
        return $this === self::DRAFT;
    }

    public function canUnpublish(): bool
    {
        return $this === self::PUBLISHED;
    }
}

======================================================================
FILE: app/Enums/OrderStatus.php (69 lines)
======================================================================
<?php

namespace App\Enums;

enum OrderStatus: string
{
    case PENDING = 'pending';
    case AWAITING_PAYMENT = 'awaiting_payment';
    case PAID = 'paid';
    case COMPLETED = 'completed';
    case EXPIRED = 'expired';
    case CANCELLED = 'cancelled';
    case REFUNDED = 'refunded';

    public function label(): string
    {
        return match ($this) {
            self::PENDING => 'Menunggu',
            self::AWAITING_PAYMENT => 'Menunggu Pembayaran',
            self::PAID => 'Dibayar',
            self::COMPLETED => 'Selesai',
            self::EXPIRED => 'Kedaluwarsa',
            self::CANCELLED => 'Dibatalkan',
            self::REFUNDED => 'Dikembalikan',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::PENDING => 'gray',
            self::AWAITING_PAYMENT => 'yellow',
            self::PAID => 'green',
            self::COMPLETED => 'blue',
            self::EXPIRED => 'red',
            self::CANCELLED => 'red',
            self::REFUNDED => 'orange',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::PENDING => 'clock',
            self::AWAITING_PAYMENT => 'credit-card',
            self::PAID => 'check-circle',
            self::COMPLETED => 'badge-check',
            self::EXPIRED => 'x-circle',
            self::CANCELLED => 'ban',
            self::REFUNDED => 'receipt-refund',
        };
    }

    public function isPaid(): bool
    {
        return in_array($this, [self::PAID, self::COMPLETED]);
    }

    public function isFinal(): bool
    {
        return in_array($this, [self::COMPLETED, self::EXPIRED, self::CANCELLED, self::REFUNDED]);
    }

    public function canRefund(): bool
    {
        return in_array($this, [self::PAID, self::COMPLETED]);
    }
}

======================================================================
FILE: app/Enums/PaymentStatus.php (45 lines)
======================================================================
<?php

namespace App\Enums;

enum PaymentStatus: string
{
    case PENDING = 'pending';
    case PAID = 'paid';
    case EXPIRED = 'expired';
    case FAILED = 'failed';
    case REFUNDED = 'refunded';

    public function label(): string
    {
        return match ($this) {
            self::PENDING => 'Menunggu',
            self::PAID => 'Dibayar',
            self::EXPIRED => 'Kedaluwarsa',
            self::FAILED => 'Gagal',
            self::REFUNDED => 'Dikembalikan',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::PENDING => 'yellow',
            self::PAID => 'green',
            self::EXPIRED => 'gray',
            self::FAILED => 'red',
            self::REFUNDED => 'orange',
        };
    }

    public function isSuccessful(): bool
    {
        return $this === self::PAID;
    }

    public function isFinal(): bool
    {
        return in_array($this, [self::PAID, self::EXPIRED, self::FAILED, self::REFUNDED]);
    }
}

======================================================================
FILE: app/Enums/SettlementStatus.php (52 lines)
======================================================================
<?php

namespace App\Enums;

enum SettlementStatus: string
{
    case PENDING = 'pending';
    case PROCESSING = 'processing';
    case TRANSFERRED = 'transferred';
    case FAILED = 'failed';

    public function label(): string
    {
        return match ($this) {
            self::PENDING => 'Menunggu',
            self::PROCESSING => 'Diproses',
            self::TRANSFERRED => 'Ditransfer',
            self::FAILED => 'Gagal',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::PENDING => 'yellow',
            self::PROCESSING => 'blue',
            self::TRANSFERRED => 'green',
            self::FAILED => 'red',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::PENDING => 'clock',
            self::PROCESSING => 'arrow-path',
            self::TRANSFERRED => 'check-circle',
            self::FAILED => 'x-circle',
        };
    }

    public function canProcess(): bool
    {
        return $this === self::PENDING;
    }

    public function canRetry(): bool
    {
        return $this === self::FAILED;
    }
}

======================================================================
FILE: app/Enums/TicketType.php (56 lines)
======================================================================
<?php

namespace App\Enums;

enum TicketType: string
{
    case REGULAR = 'regular';
    case VIP = 'vip';
    case BUNDLE = 'bundle';
    case ADDON = 'addon';
    case FREE = 'free';

    public function label(): string
    {
        return match ($this) {
            self::REGULAR => 'Regular',
            self::VIP => 'VIP',
            self::BUNDLE => 'Bundle',
            self::ADDON => 'Add-on',
            self::FREE => 'Gratis',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::REGULAR => 'blue',
            self::VIP => 'purple',
            self::BUNDLE => 'orange',
            self::ADDON => 'teal',
            self::FREE => 'green',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::REGULAR => 'ticket',
            self::VIP => 'star',
            self::BUNDLE => 'collection',
            self::ADDON => 'plus-circle',
            self::FREE => 'gift',
        };
    }

    public function isFree(): bool
    {
        return $this === self::FREE;
    }

    public function isPremium(): bool
    {
        return in_array($this, [self::VIP, self::BUNDLE]);
    }
}

======================================================================
FILE: app/Enums/UserRole.php (29 lines)
======================================================================
<?php

namespace App\Enums;

enum UserRole: string
{
    case ADMIN = 'admin';
    case ORGANIZER = 'organizer';
    case USER = 'user';

    public function label(): string
    {
        return match ($this) {
            self::ADMIN => 'Administrator',
            self::ORGANIZER => 'Penyelenggara',
            self::USER => 'Pengguna',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::ADMIN => 'red',
            self::ORGANIZER => 'blue',
            self::USER => 'gray',
        };
    }
}

======================================================================
FILE: app/Enums/VoucherType.php (40 lines)
======================================================================
<?php

namespace App\Enums;

enum VoucherType: string
{
    case FIXED = 'fixed';
    case PERCENTAGE = 'percentage';

    public function label(): string
    {
        return match ($this) {
            self::FIXED => 'Nominal Tetap',
            self::PERCENTAGE => 'Persentase',
        };
    }

    public function calculateDiscount(int $subtotal, int $value, ?int $maxDiscount = null): int
    {
        $discount = match ($this) {
            self::FIXED => $value,
            self::PERCENTAGE => (int) ceil($subtotal * $value / 100),
        };

        if ($maxDiscount !== null && $discount > $maxDiscount) {
            return $maxDiscount;
        }

        return min($discount, $subtotal);
    }

    public function formatValue(int $value): string
    {
        return match ($this) {
            self::FIXED => 'Rp ' . number_format($value, 0, ',', '.'),
            self::PERCENTAGE => $value . '%',
        };
    }
}

======================================================================
FILE: app/Events/OrderPaid.php (1 lines)
======================================================================


======================================================================
FILE: app/Events/TicketIssued.php (1 lines)
======================================================================


======================================================================
FILE: app/Exceptions/InsufficientTicketException.php (49 lines)
======================================================================
<?php

namespace App\Exceptions;

use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;

class InsufficientTicketException extends Exception
{
    public function __construct(
        public int $ticketVariantId,
        public int $requested,
        public int $available,
        string $message = null
    ) {
        parent::__construct(
            $message ?? "Stok tiket tidak mencukupi. Diminta: {$requested}, Tersedia: {$available}"
        );
    }

    public function render(Request $request): JsonResponse|RedirectResponse
    {
        if ($request->expectsJson()) {
            return response()->json([
                'error' => 'insufficient_stock',
                'message' => 'Tiket tidak tersedia dalam jumlah yang diminta',
                'details' => [
                    'ticket_variant_id' => $this->ticketVariantId,
                    'requested' => $this->requested,
                    'available' => $this->available,
                ],
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }

        return back()->withErrors([
            'ticket' => 'Tiket tidak tersedia dalam jumlah yang diminta. Tersedia: ' . $this->available
        ])->withInput();
    }

    public function report(): bool
    {
        // Don't report to error tracking - this is expected user behavior
        return false;
    }
}

======================================================================
FILE: app/Exceptions/PaymentFailedException.php (52 lines)
======================================================================
<?php

namespace App\Exceptions;

use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;

class PaymentFailedException extends Exception
{
    public function __construct(
        public ?int $orderId = null,
        public ?string $reason = null,
        string $message = null
    ) {
        parent::__construct($message ?? 'Pembayaran gagal diproses');
    }

    public function render(Request $request): JsonResponse|RedirectResponse
    {
        if ($request->expectsJson()) {
            return response()->json([
                'error' => 'payment_failed',
                'message' => $this->getMessage(),
                'reason' => $this->reason,
            ], Response::HTTP_PAYMENT_REQUIRED);
        }

        if ($this->orderId) {
            return redirect()
                ->route('checkout.failed', ['order' => $this->orderId])
                ->with('error', $this->getMessage());
        }

        return back()->withErrors([
            'payment' => $this->getMessage()
        ]);
    }

    public function report(): void
    {
        // Log payment failures for monitoring
        logger()->channel('payment')->error('Payment failed', [
            'order_id' => $this->orderId,
            'reason' => $this->reason,
            'message' => $this->getMessage(),
        ]);
    }
}

======================================================================
FILE: app/Exceptions/VoucherInvalidException.php (61 lines)
======================================================================
<?php

namespace App\Exceptions;

use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;

class VoucherInvalidException extends Exception
{
    public const REASON_NOT_FOUND = 'not_found';
    public const REASON_EXPIRED = 'expired';
    public const REASON_USAGE_LIMIT = 'usage_limit';
    public const REASON_USER_LIMIT = 'user_limit';
    public const REASON_MIN_PURCHASE = 'min_purchase';
    public const REASON_NOT_APPLICABLE = 'not_applicable';
    public const REASON_INACTIVE = 'inactive';

    public function __construct(
        public string $code,
        public string $reason = self::REASON_NOT_FOUND,
        string $message = null
    ) {
        $defaultMessages = [
            self::REASON_NOT_FOUND => 'Kode voucher tidak ditemukan',
            self::REASON_EXPIRED => 'Voucher sudah kedaluwarsa',
            self::REASON_USAGE_LIMIT => 'Voucher sudah mencapai batas penggunaan',
            self::REASON_USER_LIMIT => 'Anda sudah mencapai batas penggunaan voucher ini',
            self::REASON_MIN_PURCHASE => 'Minimum pembelian belum tercapai',
            self::REASON_NOT_APPLICABLE => 'Voucher tidak berlaku untuk event ini',
            self::REASON_INACTIVE => 'Voucher tidak aktif',
        ];

        parent::__construct($message ?? ($defaultMessages[$reason] ?? 'Voucher tidak valid'));
    }

    public function render(Request $request): JsonResponse|RedirectResponse
    {
        if ($request->expectsJson()) {
            return response()->json([
                'error' => 'voucher_invalid',
                'message' => $this->getMessage(),
                'reason' => $this->reason,
                'code' => $this->code,
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }

        return back()->withErrors([
            'voucher' => $this->getMessage()
        ])->withInput();
    }

    public function report(): bool
    {
        // Don't report to error tracking - this is expected user behavior
        return false;
    }
}

======================================================================
FILE: app/Http/Controllers/Admin/CategoryController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Admin/DashboardController.php (26 lines)
======================================================================
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\Order;
use App\Models\User;
use App\Models\Organizer;
use Illuminate\View\View;

class DashboardController extends Controller
{
    public function index(): View
    {
        $stats = [
            'total_users' => User::count(),
            'total_organizers' => Organizer::count(),
            'total_events' => Event::count(),
            'total_orders' => Order::count(),
        ];

        return view('admin.dashboard.index', compact('stats'));
    }
}

======================================================================
FILE: app/Http/Controllers/Admin/EventController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Admin/SettlementController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Admin/UserController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Admin/VoucherController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Auth/ForgotPasswordController.php (32 lines)
======================================================================
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Illuminate\View\View;

class ForgotPasswordController extends Controller
{
    public function showLinkRequestForm(): View
    {
        return view('auth.forgot-password');
    }

    public function sendResetLinkEmail(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status === Password::RESET_LINK_SENT
            ? back()->with(['status' => __($status)])
            : back()->withErrors(['email' => __($status)]);
    }
}

======================================================================
FILE: app/Http/Controllers/Auth/LoginController.php (44 lines)
======================================================================
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\View\View;

class LoginController extends Controller
{
    public function showLoginForm(): View
    {
        return view('auth.login');
    }

    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::attempt($credentials, $request->boolean('remember'))) {
            $request->session()->regenerate();

            return redirect()->intended('/');
        }

        return back()->withErrors([
            'email' => 'Email atau password salah.',
        ])->onlyInput('email');
    }

    public function logout(Request $request)
    {
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect('/');
    }
}

======================================================================
FILE: app/Http/Controllers/Auth/RegisterController.php (70 lines)
======================================================================
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Enums\UserRole;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\View\View;

class RegisterController extends Controller
{
    public function showRegistrationForm(): View
    {
        return view('auth.register');
    }

    public function register(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8|confirmed',
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => UserRole::USER,
        ]);

        Auth::login($user);

        return redirect('/');
    }

    public function showOrganizerForm(): View
    {
        return view('auth.register-organizer');
    }

    public function registerOrganizer(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8|confirmed',
            'organizer_name' => 'required|string|max:255',
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => UserRole::ORGANIZER,
        ]);

        $user->organizer()->create([
            'name' => $request->organizer_name,
        ]);

        Auth::login($user);

        return redirect()->route('organizer.dashboard');
    }
}

======================================================================
FILE: app/Http/Controllers/Auth/ResetPasswordController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Auth/VerifyEmailController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/Controller.php (9 lines)
======================================================================
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}

======================================================================
FILE: app/Http/Controllers/Organizer/AttendeeController.php (95 lines)
======================================================================
<?php

namespace App\Http\Controllers\Organizer;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\IssuedTicket;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class AttendeeController extends Controller
{
    public function index(): View
    {
        $organizer = auth()->user()->organizer;

        $events = Event::where('organizer_id', $organizer->id)
            ->where('status', 'published')
            ->withCount(['issuedTickets', 'issuedTickets as checked_in_count' => function ($query) {
                $query->where('is_used', true);
            }])
            ->orderBy('start_date', 'desc')
            ->get();

        return view('organizer.attendees.index', compact('events'));
    }

    public function event(Event $event, Request $request): View
    {
        $organizer = auth()->user()->organizer;

        if ($event->organizer_id !== $organizer->id) {
            abort(403);
        }

        $query = IssuedTicket::with(['orderItem.order', 'orderItem'])
            ->whereHas('orderItem.order', function ($q) use ($event) {
                $q->where('event_id', $event->id)
                  ->where('status', 'paid');
            });

        if ($request->filled('search')) {
            $query->where(function ($q) use ($request) {
                $q->where('code', 'like', '%' . $request->search . '%')
                  ->orWhere('attendee_name', 'like', '%' . $request->search . '%')
                  ->orWhere('attendee_email', 'like', '%' . $request->search . '%');
            });
        }

        if ($request->filled('status')) {
            if ($request->status === 'checked_in') {
                $query->where('is_used', true);
            } else {
                $query->where('is_used', false);
            }
        }

        $attendees = $query->orderBy('attendee_name')->paginate(20);

        $stats = [
            'total' => IssuedTicket::whereHas('orderItem.order', function ($q) use ($event) {
                $q->where('event_id', $event->id)->where('status', 'paid');
            })->count(),
            'checked_in' => IssuedTicket::whereHas('orderItem.order', function ($q) use ($event) {
                $q->where('event_id', $event->id)->where('status', 'paid');
            })->where('is_used', true)->count(),
        ];

        return view('organizer.attendees.event', compact('event', 'attendees', 'stats'));
    }

    public function checkin(IssuedTicket $ticket): RedirectResponse
    {
        $organizer = auth()->user()->organizer;
        $event = $ticket->orderItem->order->event;

        if ($event->organizer_id !== $organizer->id) {
            abort(403);
        }

        if ($ticket->is_used) {
            return back()->with('error', 'Tiket sudah digunakan pada ' . $ticket->used_at->format('d M Y H:i'));
        }

        $ticket->update([
            'is_used' => true,
            'used_at' => now(),
            'used_by' => auth()->id(),
        ]);

        return back()->with('success', 'Check-in berhasil untuk ' . $ticket->attendee_name);
    }
}

======================================================================
FILE: app/Http/Controllers/Organizer/DashboardController.php (47 lines)
======================================================================
<?php

namespace App\Http\Controllers\Organizer;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\Order;
use App\Enums\OrderStatus;
use Illuminate\View\View;

class DashboardController extends Controller
{
    public function index(): View
    {
        $organizer = auth()->user()->organizer;

        if (!$organizer) {
            abort(403, 'Anda belum terdaftar sebagai organizer');
        }

        $eventIds = Event::where('organizer_id', $organizer->id)->pluck('id');

        $stats = [
            'total_events' => Event::where('organizer_id', $organizer->id)->count(),
            'published_events' => Event::where('organizer_id', $organizer->id)->where('status', 'published')->count(),
            'total_orders' => Order::whereIn('event_id', $eventIds)->count(),
            'total_revenue' => Order::whereIn('event_id', $eventIds)->where('status', OrderStatus::PAID)->sum('subtotal'),
            'total_tickets_sold' => Order::whereIn('event_id', $eventIds)->where('status', OrderStatus::PAID)->withSum('items', 'quantity')->get()->sum('items_sum_quantity'),
        ];

        $recentOrders = Order::with(['event', 'user'])
            ->whereIn('event_id', $eventIds)
            ->latest()
            ->take(5)
            ->get();

        $upcomingEvents = Event::where('organizer_id', $organizer->id)
            ->where('start_date', '>=', now())
            ->where('status', 'published')
            ->orderBy('start_date')
            ->take(5)
            ->get();

        return view('organizer.dashboard', compact('stats', 'recentOrders', 'upcomingEvents', 'organizer'));
    }
}

======================================================================
FILE: app/Http/Controllers/Organizer/EventController.php (360 lines)
======================================================================
<?php

namespace App\Http\Controllers\Organizer;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\Category;
use App\Models\Ticket;
use App\Models\TicketVariant;
use App\Models\EventDay;
use App\Enums\EventStatus;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use Illuminate\View\View;
use Carbon\Carbon;

class EventController extends Controller
{
    public function index(Request $request): View
    {
        $organizer = auth()->user()->organizer;

        $query = Event::where('organizer_id', $organizer->id)
            ->withCount(['orders', 'tickets']);

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('search')) {
            $query->where('title', 'like', '%' . $request->search . '%');
        }

        $events = $query->latest()->paginate(10);

        return view('organizer.events.index', compact('events'));
    }

    public function create(): View
    {
        $categories = Category::where('is_active', true)
            ->orderBy('sort_order')
            ->orderBy('name')
            ->get();

        return view('organizer.events.create', compact('categories'));
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'category_id' => 'required|exists:categories,id',
            'description' => 'required|string|min:100',
            'start_date' => 'required|date|after:today',
            'end_date' => 'required|date|after_or_equal:start_date',
            'start_time' => 'required|date_format:H:i',
            'end_time' => 'required|date_format:H:i',
            'venue_name' => 'required|string|max:255',
            'venue_address' => 'required|string|max:500',
            'city' => 'required|string|max:100',
            'province' => 'required|string|max:100',
            'poster' => 'nullable|image|mimes:jpg,jpeg,png|max:2048',
            'is_online' => 'boolean',
            'online_url' => 'nullable|url|required_if:is_online,true',
            'tickets' => 'required|array|min:1',
            'tickets.*.name' => 'required|string|max:255',
            'tickets.*.price' => 'required|numeric|min:0',
            'tickets.*.stock' => 'required|integer|min:1',
        ], [
            'title.required' => 'Judul event wajib diisi',
            'description.min' => 'Deskripsi minimal 100 karakter',
            'start_date.after' => 'Tanggal mulai harus setelah hari ini',
            'tickets.required' => 'Minimal 1 jenis tiket harus dibuat',
            'tickets.min' => 'Minimal 1 jenis tiket harus dibuat',
        ]);

        $organizer = auth()->user()->organizer;

        try {
            DB::beginTransaction();

            // Upload poster
            $posterPath = null;
            if ($request->hasFile('poster')) {
                $posterPath = $request->file('poster')->store('events/posters', 'public');
            }

            // Create event
            $event = Event::create([
                'organizer_id' => $organizer->id,
                'category_id' => $validated['category_id'],
                'title' => $validated['title'],
                'slug' => Str::slug($validated['title']) . '-' . Str::random(6),
                'description' => $validated['description'],
                'start_date' => $validated['start_date'],
                'end_date' => $validated['end_date'],
                'start_time' => $validated['start_time'],
                'end_time' => $validated['end_time'],
                'timezone' => 'Asia/Jakarta',
                'venue_name' => $validated['venue_name'],
                'venue_address' => $validated['venue_address'],
                'city' => $validated['city'],
                'province' => $validated['province'],
                'poster' => $posterPath,
                'is_online' => $request->boolean('is_online'),
                'online_url' => $validated['online_url'] ?? null,
                'status' => EventStatus::DRAFT,
                'is_free' => collect($validated['tickets'])->every(fn($t) => $t['price'] == 0),
            ]);

            // Create tickets
            $minPrice = null;
            $maxPrice = null;

            foreach ($validated['tickets'] as $index => $ticketData) {
                $ticket = $event->tickets()->create([
                    'name' => $ticketData['name'],
                    'type' => $ticketData['price'] == 0 ? 'free' : 'regular',
                    'sort_order' => $index + 1,
                    'is_active' => true,
                ]);

                $ticket->variants()->create([
                    'name' => null,
                    'price' => $ticketData['price'],
                    'stock' => $ticketData['stock'],
                    'is_active' => true,
                ]);

                $price = (int) $ticketData['price'];
                if ($minPrice === null || $price < $minPrice) $minPrice = $price;
                if ($maxPrice === null || $price > $maxPrice) $maxPrice = $price;
            }

            $event->update([
                'min_price' => $minPrice,
                'max_price' => $maxPrice,
            ]);

            // Create event days
            $currentDate = Carbon::parse($validated['start_date']);
            $endDate = Carbon::parse($validated['end_date']);
            $dayNumber = 1;

            while ($currentDate->lte($endDate)) {
                EventDay::create([
                    'event_id' => $event->id,
                    'date' => $currentDate->format('Y-m-d'),
                    'name' => 'Hari ' . $dayNumber,
                    'start_time' => $validated['start_time'],
                    'end_time' => $validated['end_time'],
                ]);
                $currentDate->addDay();
                $dayNumber++;
            }

            DB::commit();

            return redirect()->route('organizer.events.show', $event)
                ->with('success', 'Event berhasil dibuat. Anda dapat mempublikasikan event sekarang.');

        } catch (\Exception $e) {
            DB::rollBack();
            return back()->with('error', 'Gagal membuat event: ' . $e->getMessage())->withInput();
        }
    }

    public function show(Event $event): View
    {
        $this->authorizeEvent($event);

        $event->load(['category', 'tickets.variants', 'days']);

        $stats = [
            'total_orders' => $event->orders()->count(),
            'paid_orders' => $event->orders()->whereIn('status', ['paid', 'completed'])->count(),
            'total_revenue' => $event->orders()->whereIn('status', ['paid', 'completed'])->sum('subtotal'),
            'tickets_sold' => $event->orders()
                ->whereIn('status', ['paid', 'completed'])
                ->join('order_items', 'orders.id', '=', 'order_items.order_id')
                ->sum('order_items.quantity'),
        ];

        return view('organizer.events.show', compact('event', 'stats'));
    }

    public function edit(Event $event): View
    {
        $this->authorizeEvent($event);

        if (!$event->status->canEdit()) {
            abort(403, 'Event yang sudah dipublikasi tidak dapat diedit');
        }

        $categories = Category::where('is_active', true)
            ->orderBy('sort_order')
            ->orderBy('name')
            ->get();

        $event->load(['tickets.variants']);

        return view('organizer.events.edit', compact('event', 'categories'));
    }

    public function update(Request $request, Event $event): RedirectResponse
    {
        $this->authorizeEvent($event);

        if (!$event->status->canEdit()) {
            return back()->with('error', 'Event yang sudah dipublikasi tidak dapat diedit');
        }

        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'category_id' => 'required|exists:categories,id',
            'description' => 'required|string|min:100',
            'start_date' => 'required|date',
            'end_date' => 'required|date|after_or_equal:start_date',
            'start_time' => 'required|date_format:H:i',
            'end_time' => 'required|date_format:H:i',
            'venue_name' => 'required|string|max:255',
            'venue_address' => 'required|string|max:500',
            'city' => 'required|string|max:100',
            'province' => 'required|string|max:100',
            'poster' => 'nullable|image|mimes:jpg,jpeg,png|max:2048',
            'is_online' => 'boolean',
            'online_url' => 'nullable|url|required_if:is_online,true',
        ]);

        try {
            // Upload poster baru jika ada
            if ($request->hasFile('poster')) {
                if ($event->poster) {
                    \Storage::disk('public')->delete($event->poster);
                }
                $validated['poster'] = $request->file('poster')->store('events/posters', 'public');
            }

            $event->update($validated);

            return redirect()->route('organizer.events.show', $event)
                ->with('success', 'Event berhasil diperbarui');

        } catch (\Exception $e) {
            return back()->with('error', 'Gagal memperbarui event: ' . $e->getMessage())->withInput();
        }
    }

    public function destroy(Event $event): RedirectResponse
    {
        $this->authorizeEvent($event);

        if (!$event->status->canDelete()) {
            return back()->with('error', 'Event yang sudah dipublikasi tidak dapat dihapus');
        }

        if ($event->orders()->exists()) {
            return back()->with('error', 'Event tidak dapat dihapus karena sudah ada pesanan');
        }

        try {
            if ($event->poster) {
                \Storage::disk('public')->delete($event->poster);
            }
            $event->delete();

            return redirect()->route('organizer.events.index')
                ->with('success', 'Event berhasil dihapus');
        } catch (\Exception $e) {
            return back()->with('error', 'Gagal menghapus event');
        }
    }

    public function publish(Event $event): RedirectResponse
    {
        $this->authorizeEvent($event);

        if (!$event->status->canPublish()) {
            return back()->with('error', 'Event tidak dapat dipublikasikan');
        }

        // Validasi kelengkapan
        $errors = [];

        if (!$event->poster) {
            $errors[] = 'Poster event wajib diupload';
        }

        if (strlen($event->description) < 100) {
            $errors[] = 'Deskripsi minimal 100 karakter';
        }

        if ($event->tickets()->count() === 0) {
            $errors[] = 'Minimal 1 jenis tiket harus dibuat';
        }

        if ($event->start_date->isPast()) {
            $errors[] = 'Tanggal event sudah lewat';
        }

        // Check email verification
        if (!auth()->user()->hasVerifiedEmail()) {
            $errors[] = 'Email Anda belum diverifikasi. Silakan cek inbox email Anda.';
        }

        if (!empty($errors)) {
            return back()->with('error', implode(', ', $errors));
        }

        $event->update([
            'status' => EventStatus::PUBLISHED,
            'published_at' => now(),
        ]);

        return back()->with('success', 'Event berhasil dipublikasikan dan sekarang dapat dilihat oleh publik');
    }

    public function unpublish(Event $event): RedirectResponse
    {
        $this->authorizeEvent($event);

        if (!$event->status->canUnpublish()) {
            return back()->with('error', 'Event tidak dapat di-unpublish');
        }

        // Check if ada orders yang paid
        $paidOrders = $event->orders()->whereIn('status', ['paid', 'completed'])->count();
        if ($paidOrders > 0) {
            return back()->with('error', "Event tidak dapat di-unpublish karena sudah ada {$paidOrders} tiket terjual");
        }

        $event->update([
            'status' => EventStatus::DRAFT,
            'published_at' => null,
        ]);

        // Release reserved tickets
        foreach ($event->orders()->where('status', 'pending')->get() as $order) {
            foreach ($order->items as $item) {
                $item->ticketVariant?->decrement('reserved_count', $item->quantity);
            }
            $order->update(['status' => 'expired']);
        }

        return back()->with('success', 'Event berhasil di-unpublish dan tidak lagi terlihat oleh publik');
    }

    protected function authorizeEvent(Event $event): void
    {
        $organizer = auth()->user()->organizer;

        if (!$organizer || $event->organizer_id !== $organizer->id) {
            abort(403);
        }
    }
}

======================================================================
FILE: app/Http/Controllers/Organizer/OrderController.php (59 lines)
======================================================================
<?php

namespace App\Http\Controllers\Organizer;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\Order;
use Illuminate\Http\Request;
use Illuminate\View\View;

class OrderController extends Controller
{
    public function index(Request $request): View
    {
        $organizer = auth()->user()->organizer;
        $eventIds = Event::where('organizer_id', $organizer->id)->pluck('id');

        $query = Order::with(['event', 'user', 'items'])
            ->whereIn('event_id', $eventIds);

        if ($request->filled('event_id')) {
            $query->where('event_id', $request->event_id);
        }

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('search')) {
            $query->where(function ($q) use ($request) {
                $q->where('order_number', 'like', '%' . $request->search . '%')
                  ->orWhere('customer_name', 'like', '%' . $request->search . '%')
                  ->orWhere('customer_email', 'like', '%' . $request->search . '%');
            });
        }

        $orders = $query->latest()->paginate(15);

        $events = Event::where('organizer_id', $organizer->id)
            ->orderBy('title')
            ->get();

        return view('organizer.orders.index', compact('orders', 'events'));
    }

    public function show(Order $order): View
    {
        $organizer = auth()->user()->organizer;

        if ($order->event->organizer_id !== $organizer->id) {
            abort(403);
        }

        $order->load(['event', 'user', 'items.ticket', 'items.ticketVariant', 'issuedTickets']);

        return view('organizer.orders.show', compact('order'));
    }
}

======================================================================
FILE: app/Http/Controllers/Organizer/ProfileController.php (39 lines)
======================================================================
<?php

namespace App\Http\Controllers\Organizer;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ProfileController extends Controller
{
    public function index(): View
    {
        $organizer = auth()->user()->organizer;
        return view('organizer.settings.index', compact('organizer'));
    }

    public function update(Request $request): RedirectResponse
    {
        $organizer = auth()->user()->organizer;

        $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'email' => 'required|email|max:255',
            'phone' => 'nullable|string|max:20',
            'website' => 'nullable|url|max:255',
            'instagram' => 'nullable|string|max:100',
            'address' => 'nullable|string|max:500',
        ]);

        $organizer->update($request->only([
            'name', 'description', 'email', 'phone', 'website', 'instagram', 'address'
        ]));

        return back()->with('success', 'Pengaturan organizer berhasil diperbarui');
    }
}

======================================================================
FILE: app/Http/Controllers/Organizer/TicketController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Controllers/User/CheckoutController.php (277 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Models\Order;
use App\Models\OrderItem;
use App\Models\TicketVariant;
use App\Enums\OrderStatus;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;

class CheckoutController extends Controller
{
    public function index(Event $event): View|RedirectResponse
    {
        if (!$event->isPublished()) {
            abort(404);
        }

        if ($event->isPast()) {
            return redirect()->route('events.show', $event)
                ->with('error', 'Event sudah berakhir');
        }

        $event->load(['tickets.variants' => function ($query) {
            $query->where('is_active', true);
        }, 'days']);

        return view('pages.checkout.index', compact('event'));
    }

    public function store(Request $request, Event $event): RedirectResponse
    {
        $request->validate([
            'tickets' => 'required|array|min:1',
            'tickets.*.variant_id' => 'required|exists:ticket_variants,id',
            'tickets.*.quantity' => 'required|integer|min:0|max:10',
            'voucher_code' => 'nullable|string|max:50',
            'customer_name' => 'required|string|max:255',
            'customer_email' => 'required|email|max:255',
            'customer_phone' => 'required|string|max:20',
        ]);

        $selectedTickets = collect($request->tickets)->filter(fn($t) => $t['quantity'] > 0);

        if ($selectedTickets->isEmpty()) {
            return back()->with('error', 'Pilih minimal 1 tiket');
        }

        try {
            DB::beginTransaction();

            $orderItems = [];
            $subtotal = 0;

            foreach ($selectedTickets as $ticketData) {
                $variant = TicketVariant::with('ticket')->findOrFail($ticketData['variant_id']);

                if ($variant->ticket->event_id !== $event->id) {
                    throw new \Exception('Tiket tidak valid untuk event ini');
                }

                $available = $variant->stock - $variant->sold_count - $variant->reserved_count;
                if ($ticketData['quantity'] > $available) {
                    throw new \Exception("Tiket {$variant->ticket->name} tidak cukup tersedia");
                }

                $variant->increment('reserved_count', $ticketData['quantity']);

                $itemSubtotal = $variant->price * $ticketData['quantity'];
                $subtotal += $itemSubtotal;

                $orderItems[] = [
                    'variant' => $variant,
                    'quantity' => $ticketData['quantity'],
                    'price' => $variant->price,
                    'subtotal' => $itemSubtotal,
                ];
            }

            $platformFee = 0;
            $paymentFee = (int) ceil($subtotal * 0.025);
            $discount = 0;
            $voucherId = null;
            $total = $subtotal + $paymentFee - $discount;

            $order = Order::create([
                'user_id' => auth()->id(),
                'event_id' => $event->id,
                'voucher_id' => $voucherId,
                'order_number' => $this->generateOrderNumber(),
                'status' => OrderStatus::PENDING,
                'subtotal' => $subtotal,
                'discount' => $discount,
                'platform_fee' => $platformFee,
                'payment_fee' => $paymentFee,
                'total' => $total,
                'customer_name' => $request->customer_name,
                'customer_email' => $request->customer_email,
                'customer_phone' => $request->customer_phone,
                'expires_at' => now()->addMinutes(15),
            ]);

            foreach ($orderItems as $item) {
                OrderItem::create([
                    'order_id' => $order->id,
                    'ticket_id' => $item['variant']->ticket_id,
                    'ticket_variant_id' => $item['variant']->id,
                    'ticket_name' => $item['variant']->ticket->name,
                    'variant_name' => $item['variant']->name,
                    'quantity' => $item['quantity'],
                    'unit_price' => $item['price'],
                    'subtotal' => $item['subtotal'],
                ]);
            }

            DB::commit();

            return redirect()->route('checkout.payment', $order);

        } catch (\Exception $e) {
            DB::rollBack();
            return back()->with('error', $e->getMessage())->withInput();
        }
    }

    public function payment(Order $order): View|RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $status = $order->status instanceof OrderStatus ? $order->status->value : $order->status;

        if ($status !== 'pending') {
            return redirect()->route('orders.show', $order);
        }

        // Cek expired
        if ($order->expires_at && $order->expires_at->isPast()) {
            return redirect()->route('checkout.expired', $order);
        }

        $order->load(['event', 'items.ticket', 'items.ticketVariant']);

        return view('pages.checkout.payment', compact('order'));
    }

    public function processPayment(Request $request, Order $order): RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $status = $order->status instanceof OrderStatus ? $order->status->value : $order->status;

        if ($status !== 'pending') {
            return redirect()->route('orders.show', $order);
        }

        try {
            DB::beginTransaction();

            $order->update([
                'status' => OrderStatus::PAID,
                'paid_at' => now(),
            ]);

            foreach ($order->items as $item) {
                if ($item->ticketVariant) {
                    $item->ticketVariant->decrement('reserved_count', $item->quantity);
                    $item->ticketVariant->increment('sold_count', $item->quantity);
                }
            }

            $this->generateIssuedTickets($order);

            DB::commit();

            return redirect()->route('checkout.success', $order);

        } catch (\Exception $e) {
            DB::rollBack();
            return redirect()->route('checkout.failed', $order)
                ->with('error', $e->getMessage());
        }
    }

    public function success(Order $order): View|RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $order->load(['event', 'items', 'issuedTickets.orderItem']);

        return view('pages.checkout.success', compact('order'));
    }

    public function failed(Order $order): View|RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $order->load(['event']);

        return view('pages.checkout.failed', compact('order'));
    }

    public function expired(Order $order): View|RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $status = $order->status instanceof OrderStatus ? $order->status->value : $order->status;

        if ($status === 'pending') {
            $this->releaseReservedTickets($order);
            $order->update(['status' => OrderStatus::EXPIRED]);
        }

        $order->load(['event']);

        return view('pages.checkout.expired', compact('order'));
    }

    protected function generateOrderNumber(): string
    {
        $prefix = 'NGE';
        $date = now()->format('Ymd');
        $random = strtoupper(substr(uniqid(), -6));

        return "{$prefix}{$date}{$random}";
    }

    protected function generateIssuedTickets(Order $order): void
    {
        foreach ($order->items as $item) {
            for ($i = 0; $i < $item->quantity; $i++) {
                $order->issuedTickets()->create([
                    'user_id' => $order->user_id,
                    'order_item_id' => $item->id,
                    'code' => $this->generateTicketCode(),
                    'attendee_name' => $order->customer_name,
                    'attendee_email' => $order->customer_email,
                    'attendee_phone' => $order->customer_phone,
                    'status' => 'active',
                ]);
            }
        }
    }

    protected function generateTicketCode(): string
    {
        do {
            $code = strtoupper(substr(md5(uniqid(mt_rand(), true)), 0, 12));
        } while (\App\Models\IssuedTicket::where('code', $code)->exists());

        return $code;
    }

    protected function releaseReservedTickets(Order $order): void
    {
        foreach ($order->items as $item) {
            if ($item->ticketVariant) {
                $item->ticketVariant->decrement('reserved_count', $item->quantity);
            }
        }
    }
}

======================================================================
FILE: app/Http/Controllers/User/EventController.php (81 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\Category;
use App\Models\Event;
use App\Models\Organizer;
use Illuminate\Http\Request;
use Illuminate\View\View;

class EventController extends Controller
{
    public function index(Request $request): View
    {
        $query = Event::with(['organizer', 'category'])
            ->published()
            ->upcoming();

        if ($request->filled('category')) {
            $query->where('category_id', $request->category);
        }

        if ($request->filled('city')) {
            $query->where('city', $request->city);
        }

        if ($request->filled('search')) {
            $query->search($request->search);
        }

        $events = $query->orderBy('start_date')->paginate(12);
        $categories = Category::active()->ordered()->get();

        return view('pages.events.index', compact('events', 'categories'));
    }

    public function show(Event $event): View
    {
        if (!$event->isPublished()) {
            abort(404);
        }

        $event->load(['organizer.socialLinks', 'category', 'subcategories', 'days', 'tickets.variants']);
        $event->incrementViews();

        $relatedEvents = Event::with(['organizer', 'category'])
            ->published()
            ->upcoming()
            ->where('category_id', $event->category_id)
            ->where('id', '!=', $event->id)
            ->limit(4)
            ->get();

        return view('pages.events.show', compact('event', 'relatedEvents'));
    }

    public function category(Category $category): View
    {
        $events = Event::with(['organizer', 'category'])
            ->published()
            ->upcoming()
            ->where('category_id', $category->id)
            ->orderBy('start_date')
            ->paginate(12);

        return view('pages.events.category', compact('category', 'events'));
    }

    public function organizer(Organizer $organizer): View
    {
        $events = Event::with(['category'])
            ->published()
            ->where('organizer_id', $organizer->id)
            ->orderBy('start_date', 'desc')
            ->paginate(12);

        return view('pages.organizers.show', compact('organizer', 'events'));
    }
}

======================================================================
FILE: app/Http/Controllers/User/HomeController.php (37 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\Category;
use App\Models\Event;
use Illuminate\View\View;

class HomeController extends Controller
{
    public function index(): View
    {
        $categories = Category::active()
            ->ordered()
            ->withCount(['events' => fn($q) => $q->where('status', 'published')])
            ->get();

        $featuredEvents = Event::with(['organizer', 'category'])
            ->published()
            ->upcoming()
            ->where('is_featured', true)
            ->orderBy('start_date')
            ->limit(6)
            ->get();

        $upcomingEvents = Event::with(['organizer', 'category'])
            ->published()
            ->upcoming()
            ->orderBy('start_date')
            ->limit(8)
            ->get();

        return view('pages.home.index', compact('categories', 'featuredEvents', 'upcomingEvents'));
    }
}

======================================================================
FILE: app/Http/Controllers/User/OrderController.php (64 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\Order;
use App\Enums\OrderStatus;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class OrderController extends Controller
{
    public function index(Request $request): View
    {
        $orders = Order::with(['event', 'items'])
            ->where('user_id', auth()->id())
            ->latest()
            ->paginate(10);

        return view('pages.orders.index', compact('orders'));
    }

    public function show(Order $order): View
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        $order->load(['event', 'items.ticket', 'items.ticketVariant', 'issuedTickets.orderItem']);

        return view('pages.orders.show', compact('order'));
    }

    public function cancel(Request $request, Order $order): RedirectResponse
    {
        if ($order->user_id !== auth()->id()) {
            abort(403);
        }

        // Cek status - convert enum ke string jika perlu
        $status = $order->status instanceof OrderStatus ? $order->status->value : $order->status;

        if ($status !== 'pending') {
            return back()->with('error', 'Pesanan tidak dapat dibatalkan');
        }

        // Release reserved tickets
        foreach ($order->items as $item) {
            if ($item->ticketVariant) {
                $item->ticketVariant->decrement('reserved_count', $item->quantity);
            }
        }

        $order->update([
            'status' => OrderStatus::CANCELLED,
            'cancelled_at' => now(),
            'cancellation_reason' => 'Dibatalkan oleh user',
        ]);

        return redirect()->route('orders.index')->with('success', 'Pesanan berhasil dibatalkan');
    }
}

======================================================================
FILE: app/Http/Controllers/User/ProfileController.php (63 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rule;
use Illuminate\View\View;

class ProfileController extends Controller
{
    public function index(): View
    {
        return view('pages.profile.index');
    }

    public function edit(): View
    {
        return view('pages.profile.edit');
    }

    public function update(Request $request): RedirectResponse
    {
        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'email' => [
                'required',
                'string',
                'email',
                'max:255',
                Rule::unique('users')->ignore($user->id),
            ],
            'phone' => 'nullable|string|max:20',
        ]);

        $user->update([
            'name' => $request->name,
            'email' => $request->email,
            'phone' => $request->phone,
        ]);

        return back()->with('success', 'Profil berhasil diperbarui');
    }

    public function updatePassword(Request $request): RedirectResponse
    {
        $request->validate([
            'current_password' => 'required|current_password',
            'password' => 'required|string|min:8|confirmed',
        ]);

        auth()->user()->update([
            'password' => Hash::make($request->password),
        ]);

        return back()->with('success', 'Password berhasil diubah');
    }
}

======================================================================
FILE: app/Http/Controllers/User/TicketController.php (53 lines)
======================================================================
<?php

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\IssuedTicket;
use Barryvdh\DomPDF\Facade\Pdf;
use Illuminate\View\View;

class TicketController extends Controller
{
    public function index(): View
    {
        $tickets = IssuedTicket::with(['orderItem.order.event', 'orderItem'])
            ->where('user_id', auth()->id())
            ->latest()
            ->paginate(10);

        return view('pages.tickets.index', compact('tickets'));
    }

    public function show(string $code): View
    {
        $ticket = IssuedTicket::with(['orderItem.order.event', 'orderItem'])
            ->where('code', $code)
            ->firstOrFail();

        if ($ticket->user_id !== auth()->id()) {
            abort(403);
        }

        return view('pages.tickets.show', compact('ticket'));
    }

    public function download(string $code)
    {
        $ticket = IssuedTicket::with(['orderItem.order.event', 'orderItem.order'])
            ->where('code', $code)
            ->firstOrFail();

        if ($ticket->user_id !== auth()->id()) {
            abort(403);
        }

        // Generate QR Code tanpa imagick (tidak pakai QR untuk PDF, tampilkan code saja)
        $pdf = Pdf::loadView('pdf.ticket', compact('ticket'));

        $pdf->setPaper('a5', 'landscape');

        return $pdf->download("ticket-{$ticket->code}.pdf");
    }
}

======================================================================
FILE: app/Http/Controllers/Webhook/XenditController.php (1 lines)
======================================================================


======================================================================
FILE: app/Http/Middleware/AdminMiddleware.php (24 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class AdminMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        if (!auth()->user()->isAdmin()) {
            abort(403, 'Anda tidak memiliki akses sebagai admin');
        }

        return $next($request);
    }
}

======================================================================
FILE: app/Http/Middleware/EnsureUserIsAdmin.php (33 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class EnsureUserIsAdmin
{
    public function handle(Request $request, Closure $next): Response
    {
        // Check authentication
        if (!auth()->check()) {
            return redirect()->route('login')
                ->with('error', 'Silakan login terlebih dahulu');
        }

        // Check email verification
        if (!auth()->user()->hasVerifiedEmail()) {
            return redirect()->route('verification.notice')
                ->with('error', 'Verifikasi email Anda terlebih dahulu');
        }

        // Check if user is admin
        if (!auth()->user()->isAdmin()) {
            abort(403, 'Akses ditolak. Anda tidak memiliki akses admin.');
        }

        return $next($request);
    }
}

======================================================================
FILE: app/Http/Middleware/EnsureUserIsOrganizer.php (45 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class EnsureUserIsOrganizer
{
    public function handle(Request $request, Closure $next): Response
    {
        // Check authentication
        if (!auth()->check()) {
            return redirect()->route('login')
                ->with('error', 'Silakan login terlebih dahulu');
        }

        $user = auth()->user();

        // Check email verification
        if (!$user->hasVerifiedEmail()) {
            return redirect()->route('verification.notice')
                ->with('error', 'Verifikasi email Anda terlebih dahulu');
        }

        // Admin can access organizer panel
        if ($user->isAdmin()) {
            return $next($request);
        }

        // Check if user is organizer
        if (!$user->isOrganizer()) {
            abort(403, 'Anda tidak memiliki akses sebagai organizer. Silakan daftar sebagai organizer terlebih dahulu.');
        }

        // Check if organizer profile exists
        if (!$user->organizer) {
            abort(403, 'Profil organizer Anda belum lengkap. Silakan hubungi admin.');
        }

        return $next($request);
    }
}

======================================================================
FILE: app/Http/Middleware/OrganizerMiddleware.php (28 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class OrganizerMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        if (!auth()->user()->isOrganizer() && !auth()->user()->isAdmin()) {
            abort(403, 'Anda tidak memiliki akses sebagai organizer');
        }

        if (!auth()->user()->organizer) {
            abort(403, 'Anda belum terdaftar sebagai organizer');
        }

        return $next($request);
    }
}

======================================================================
FILE: app/Http/Middleware/ThrottleCheckout.php (39 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Cache\RateLimiter;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class ThrottleCheckout
{
    public function __construct(
        protected RateLimiter $limiter
    ) {}

    public function handle(Request $request, Closure $next): Response
    {
        $key = 'checkout:' . ($request->user()?->id ?? $request->ip());

        if ($this->limiter->tooManyAttempts($key, 5)) {
            $seconds = $this->limiter->availableIn($key);

            if ($request->expectsJson()) {
                return response()->json([
                    'message' => 'Terlalu banyak percobaan. Coba lagi dalam ' . $seconds . ' detik.',
                ], 429);
            }

            return back()->withErrors([
                'checkout' => 'Terlalu banyak percobaan checkout. Silakan coba lagi dalam ' . $seconds . ' detik.'
            ]);
        }

        $this->limiter->hit($key, 60); // 5 attempts per minute

        return $next($request);
    }
}

======================================================================
FILE: app/Http/Middleware/XenditWebhookSignature.php (29 lines)
======================================================================
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;

class XenditWebhookSignature
{
    public function handle(Request $request, Closure $next): Response
    {
        $callbackToken = $request->header('x-callback-token');
        $expectedToken = config('xendit.webhook_token');

        if (!$callbackToken || $callbackToken !== $expectedToken) {
            Log::channel('webhook')->warning('Invalid Xendit webhook signature', [
                'ip' => $request->ip(),
                'token_provided' => !empty($callbackToken),
            ]);

            return response()->json(['error' => 'Invalid signature'], 401);
        }

        return $next($request);
    }
}

======================================================================
FILE: app/Jobs/ExpireUnpaidOrders.php (1 lines)
======================================================================


======================================================================
FILE: app/Jobs/GenerateETicket.php (1 lines)
======================================================================


======================================================================
FILE: app/Jobs/SendOrderConfirmation.php (1 lines)
======================================================================


======================================================================
FILE: app/Listeners/SendTicketEmail.php (1 lines)
======================================================================


======================================================================
FILE: app/Listeners/UpdateTicketStock.php (1 lines)
======================================================================


======================================================================
FILE: app/Models/Category.php (72 lines)
======================================================================
<?php

namespace App\Models;

use App\Traits\HasSlug;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Category extends Model
{
    use HasFactory, HasSlug;

    protected $fillable = [
        'name',
        'slug',
        'description',
        'icon',
        'color',
        'sort_order',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'sort_order' => 'integer',
        ];
    }

    protected function slugSource(): string
    {
        return 'name';
    }

    public function getRouteKeyName(): string
    {
        return 'slug';
    }

    public function subcategories(): HasMany
    {
        return $this->hasMany(Subcategory::class)->orderBy('name');
    }

    public function activeSubcategories(): HasMany
    {
        return $this->subcategories()->where('is_active', true);
    }

    public function events(): HasMany
    {
        return $this->hasMany(Event::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeOrdered($query)
    {
        return $query->orderBy('sort_order')->orderBy('name');
    }

    public function getEventsCountAttribute(): int
    {
        return $this->events()->where('status', 'published')->count();
    }
}

======================================================================
FILE: app/Models/Event.php (344 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\EventStatus;
use App\Traits\HasSlug;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Event extends Model
{
    use HasFactory, HasSlug;

    protected $fillable = [
        'organizer_id',
        'category_id',
        'title',
        'slug',
        'description',
        'short_description',
        'poster',
        'banner',
        'gallery',
        'start_date',
        'end_date',
        'start_time',
        'end_time',
        'timezone',
        'venue_name',
        'venue_address',
        'city',
        'province',
        'postal_code',
        'latitude',
        'longitude',
        'is_online',
        'online_url',
        'status',
        'is_featured',
        'is_free',
        'min_price',
        'max_price',
        'proposal_file',
        'admin_notes',
        'rejection_reason',
        'published_at',
        'approved_at',
        'approved_by',
        'views_count',
    ];

    protected function casts(): array
    {
        return [
            'status' => EventStatus::class,
            'start_date' => 'date',
            'end_date' => 'date',
            'gallery' => 'array',
            'is_featured' => 'boolean',
            'is_free' => 'boolean',
            'is_online' => 'boolean',
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
            'published_at' => 'datetime',
            'approved_at' => 'datetime',
            'min_price' => 'integer',
            'max_price' => 'integer',
            'views_count' => 'integer',
        ];
    }

    protected function slugSource(): string
    {
        return 'title';
    }

    public function getRouteKeyName(): string
    {
        return 'slug';
    }

    // Relationships
    public function organizer(): BelongsTo
    {
        return $this->belongsTo(Organizer::class);
    }

    public function category(): BelongsTo
    {
        return $this->belongsTo(Category::class);
    }

    public function subcategories(): BelongsToMany
    {
        return $this->belongsToMany(Subcategory::class, 'event_subcategory');
    }

    public function days(): HasMany
    {
        return $this->hasMany(EventDay::class)->orderBy('date');
    }

    public function tickets(): HasMany
    {
        return $this->hasMany(Ticket::class)->orderBy('sort_order');
    }

    public function orders(): HasMany
    {
        return $this->hasMany(Order::class);
    }

    public function settlement(): HasOne
    {
        return $this->hasOne(Settlement::class);
    }

    public function approvedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', EventStatus::PUBLISHED);
    }

    public function scopeUpcoming($query)
    {
        return $query->where('start_date', '>=', now()->toDateString());
    }

    public function scopePast($query)
    {
        return $query->where('end_date', '<', now()->toDateString());
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeInCity($query, string $city)
    {
        return $query->where('city', $city);
    }

    public function scopeInCategory($query, $categoryId)
    {
        return $query->where('category_id', $categoryId);
    }

    public function scopeSearch($query, string $search)
    {
        return $query->where(function ($q) use ($search) {
            $q->where('title', 'like', "%{$search}%")
              ->orWhere('description', 'like', "%{$search}%")
              ->orWhere('venue_name', 'like', "%{$search}%")
              ->orWhere('city', 'like', "%{$search}%");
        });
    }

    // Status Checks
    public function isPublished(): bool
    {
        return $this->status === EventStatus::PUBLISHED;
    }

    public function isDraft(): bool
    {
        return $this->status === EventStatus::DRAFT;
    }

    public function isPendingReview(): bool
    {
        return $this->status === EventStatus::PENDING_REVIEW;
    }

    public function isCompleted(): bool
    {
        return $this->status === EventStatus::COMPLETED;
    }

    public function isCancelled(): bool
    {
        return $this->status === EventStatus::CANCELLED;
    }

    public function isMultiDay(): bool
    {
        return !$this->start_date->eq($this->end_date);
    }

    public function isUpcoming(): bool
    {
        return $this->start_date->isFuture() || $this->start_date->isToday();
    }

    public function isOngoing(): bool
    {
        return $this->start_date->isPast() && $this->end_date->isFuture();
    }

    public function isPast(): bool
    {
        return $this->end_date->isPast();
    }

    public function hasOrders(): bool
    {
        return $this->orders()->exists();
    }

    public function hasPaidOrders(): bool
    {
        return $this->orders()->whereIn('status', ['paid', 'completed'])->exists();
    }

    // Accessors
    public function getPosterUrlAttribute(): string
    {
        if ($this->poster) {
            return asset('storage/' . $this->poster);
        }

        return asset('images/default-event-poster.jpg');
    }

    public function getBannerUrlAttribute(): ?string
    {
        return $this->banner ? asset('storage/' . $this->banner) : null;
    }

    public function getFormattedDateAttribute(): string
    {
        if ($this->isMultiDay()) {
            if ($this->start_date->month === $this->end_date->month) {
                return $this->start_date->format('d') . ' - ' . $this->end_date->format('d M Y');
            }
            return $this->start_date->format('d M') . ' - ' . $this->end_date->format('d M Y');
        }

        return $this->start_date->format('d M Y');
    }

    public function getFormattedTimeAttribute(): ?string
    {
        if (!$this->start_time) {
            return null;
        }

        $start = \Carbon\Carbon::parse($this->start_time)->format('H:i');

        if ($this->end_time) {
            $end = \Carbon\Carbon::parse($this->end_time)->format('H:i');
            return "{$start} - {$end} WIB";
        }

        return "{$start} WIB";
    }

    public function getFormattedLocationAttribute(): string
    {
        $parts = array_filter([$this->venue_name, $this->city]);
        return implode(', ', $parts) ?: 'Online Event';
    }

    public function getLowestPriceAttribute(): int
    {
        return $this->tickets()
            ->join('ticket_variants', 'tickets.id', '=', 'ticket_variants.ticket_id')
            ->where('ticket_variants.is_active', true)
            ->min('ticket_variants.price') ?? 0;
    }

    public function getHighestPriceAttribute(): int
    {
        return $this->tickets()
            ->join('ticket_variants', 'tickets.id', '=', 'ticket_variants.ticket_id')
            ->where('ticket_variants.is_active', true)
            ->max('ticket_variants.price') ?? 0;
    }

    public function getFormattedPriceAttribute(): string
    {
        if ($this->is_free) {
            return 'Gratis';
        }

        $lowest = $this->lowest_price;
        $highest = $this->highest_price;

        if ($lowest === $highest) {
            return 'Rp ' . number_format($lowest, 0, ',', '.');
        }

        return 'Rp ' . number_format($lowest, 0, ',', '.') . ' - Rp ' . number_format($highest, 0, ',', '.');
    }

    // Stats
    public function getTotalTicketsSoldAttribute(): int
    {
        return $this->orders()
            ->whereIn('status', ['paid', 'completed'])
            ->join('order_items', 'orders.id', '=', 'order_items.order_id')
            ->sum('order_items.quantity');
    }

    public function getTotalRevenueAttribute(): int
    {
        return $this->orders()
            ->whereIn('status', ['paid', 'completed'])
            ->sum('subtotal');
    }

    public function getAvailableTicketsCountAttribute(): int
    {
        return $this->tickets()
            ->join('ticket_variants', 'tickets.id', '=', 'ticket_variants.ticket_id')
            ->where('ticket_variants.is_active', true)
            ->selectRaw('SUM(ticket_variants.stock - ticket_variants.sold_count - ticket_variants.reserved_count) as available')
            ->value('available') ?? 0;
    }

    // Methods
    public function incrementViews(): void
    {
        $this->increment('views_count');
    }

    public function updatePriceRange(): void
    {
        $this->update([
            'min_price' => $this->lowest_price,
            'max_price' => $this->highest_price,
        ]);
    }
}

======================================================================
FILE: app/Models/EventDay.php (89 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class EventDay extends Model
{
    use HasFactory;

    protected $fillable = [
        'event_id',
        'date',
        'name',
        'start_time',
        'end_time',
        'description',
    ];

    protected function casts(): array
    {
        return [
            'date' => 'date',
        ];
    }

    // Relationships
    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function ticketVariants(): HasMany
    {
        return $this->hasMany(TicketVariant::class);
    }

    // Accessors
    public function getFormattedDateAttribute(): string
    {
        return $this->date->translatedFormat('l, d F Y');
    }

    public function getShortDateAttribute(): string
    {
        return $this->date->format('d M');
    }

    public function getDayNameAttribute(): string
    {
        return $this->name ?: $this->date->translatedFormat('l');
    }

    public function getFormattedTimeAttribute(): ?string
    {
        if (!$this->start_time) {
            return null;
        }
        
        $start = \Carbon\Carbon::parse($this->start_time)->format('H:i');
        
        if ($this->end_time) {
            $end = \Carbon\Carbon::parse($this->end_time)->format('H:i');
            return "{$start} - {$end}";
        }
        
        return $start;
    }

    // Checks
    public function isPast(): bool
    {
        return $this->date->isPast();
    }

    public function isToday(): bool
    {
        return $this->date->isToday();
    }

    public function isFuture(): bool
    {
        return $this->date->isFuture();
    }
}

======================================================================
FILE: app/Models/IssuedTicket.php (153 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use SimpleSoftwareIO\QrCode\Facades\QrCode;
use Illuminate\Support\Str;

class IssuedTicket extends Model
{
    use HasFactory;

    protected $fillable = [
        'order_item_id',
        'user_id',
        'code',
        'qr_code',
        'attendee_name',
        'attendee_email',
        'attendee_phone',
        'is_used',
        'used_at',
        'used_by',
        'check_in_notes',
    ];

    protected function casts(): array
    {
        return [
            'is_used' => 'boolean',
            'used_at' => 'datetime',
        ];
    }

    // Relationships
    public function orderItem(): BelongsTo
    {
        return $this->belongsTo(OrderItem::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function usedByUser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'used_by');
    }

    // Accessors
    public function getEventAttribute(): ?Event
    {
        return $this->orderItem?->order?->event;
    }

    public function getTicketAttribute(): ?Ticket
    {
        return $this->orderItem?->ticket;
    }

    public function getTicketVariantAttribute(): ?TicketVariant
    {
        return $this->orderItem?->ticketVariant;
    }

    public function getQrCodeImageAttribute(): string
    {
        return 'data:image/svg+xml;base64,' . base64_encode(
            QrCode::format('svg')
                ->size(200)
                ->errorCorrection('H')
                ->generate($this->code)
        );
    }

    public function getStatusAttribute(): string
    {
        return $this->is_used ? 'Sudah Digunakan' : 'Belum Digunakan';
    }

    public function getStatusColorAttribute(): string
    {
        return $this->is_used ? 'gray' : 'green';
    }

    // Methods
    public static function generateCode(): string
    {
        do {
            $code = strtoupper(Str::random(12));
        } while (static::where('code', $code)->exists());
        
        return $code;
    }

    public function markAsUsed(?int $usedBy = null, ?string $notes = null): bool
    {
        if ($this->is_used) {
            return false;
        }

        return $this->update([
            'is_used' => true,
            'used_at' => now(),
            'used_by' => $usedBy,
            'check_in_notes' => $notes,
        ]);
    }

    public function resetUsage(): bool
    {
        return $this->update([
            'is_used' => false,
            'used_at' => null,
            'used_by' => null,
            'check_in_notes' => null,
        ]);
    }

    // Scopes
    public function scopeUsed($query)
    {
        return $query->where('is_used', true);
    }

    public function scopeUnused($query)
    {
        return $query->where('is_used', false);
    }

    public function scopeForEvent($query, $eventId)
    {
        return $query->whereHas('orderItem.order', function ($q) use ($eventId) {
            $q->where('event_id', $eventId);
        });
    }

    // Boot
    protected static function boot()
    {
        parent::boot();
        
        static::creating(function ($ticket) {
            if (!$ticket->code) {
                $ticket->code = static::generateCode();
            }
        });
    }
}

======================================================================
FILE: app/Models/Order.php (233 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\OrderStatus;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Order extends Model
{
    use HasFactory;

    protected $fillable = [
        'order_number',
        'user_id',
        'event_id',
        'voucher_id',
        'customer_name',
        'customer_email',
        'customer_phone',
        'subtotal',
        'discount',
        'platform_fee',
        'payment_fee',
        'total',
        'status',
        'notes',
        'paid_at',
        'completed_at',
        'cancelled_at',
        'cancellation_reason',
        'expires_at',
    ];

    protected function casts(): array
    {
        return [
            'status' => OrderStatus::class,
            'subtotal' => 'integer',
            'discount' => 'integer',
            'platform_fee' => 'integer',
            'payment_fee' => 'integer',
            'total' => 'integer',
            'paid_at' => 'datetime',
            'completed_at' => 'datetime',
            'cancelled_at' => 'datetime',
            'expires_at' => 'datetime',
        ];
    }

    // Relationships
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    public function payment(): HasOne
    {
        return $this->hasOne(Payment::class);
    }

    public function voucher(): BelongsTo
    {
        return $this->belongsTo(Voucher::class);
    }

    public function voucherUsage(): HasOne
    {
        return $this->hasOne(VoucherUsage::class);
    }

    public function issuedTickets(): HasManyThrough
    {
        return $this->hasManyThrough(IssuedTicket::class, OrderItem::class);
    }

    // Scopes
    public function scopePaid($query)
    {
        return $query->whereIn('status', [OrderStatus::PAID, OrderStatus::COMPLETED]);
    }

    public function scopePending($query)
    {
        return $query->whereIn('status', [OrderStatus::PENDING, OrderStatus::AWAITING_PAYMENT]);
    }

    public function scopeExpired($query)
    {
        return $query->where('status', OrderStatus::EXPIRED);
    }

    public function scopeForEvent($query, $eventId)
    {
        return $query->where('event_id', $eventId);
    }

    // Status Checks
    public function isPending(): bool
    {
        return in_array($this->status, [OrderStatus::PENDING, OrderStatus::AWAITING_PAYMENT]);
    }

    public function isPaid(): bool
    {
        return in_array($this->status, [OrderStatus::PAID, OrderStatus::COMPLETED]);
    }

    public function isCompleted(): bool
    {
        return $this->status === OrderStatus::COMPLETED;
    }

    public function isExpired(): bool
    {
        if ($this->status === OrderStatus::EXPIRED) {
            return true;
        }
        
        return $this->expires_at && $this->expires_at->isPast() && !$this->isPaid();
    }

    public function isCancelled(): bool
    {
        return $this->status === OrderStatus::CANCELLED;
    }

    public function isRefunded(): bool
    {
        return $this->status === OrderStatus::REFUNDED;
    }

    public function isFinal(): bool
    {
        return $this->status->isFinal();
    }

    public function canPay(): bool
    {
        return $this->status === OrderStatus::AWAITING_PAYMENT && !$this->isExpired();
    }

    public function canCancel(): bool
    {
        return in_array($this->status, [OrderStatus::PENDING, OrderStatus::AWAITING_PAYMENT]);
    }

    public function canRefund(): bool
    {
        return $this->status->canRefund();
    }

    // Accessors
    public function getFormattedSubtotalAttribute(): string
    {
        return 'Rp ' . number_format($this->subtotal, 0, ',', '.');
    }

    public function getFormattedDiscountAttribute(): string
    {
        return 'Rp ' . number_format($this->discount, 0, ',', '.');
    }

    public function getFormattedPlatformFeeAttribute(): string
    {
        return 'Rp ' . number_format($this->platform_fee, 0, ',', '.');
    }

    public function getFormattedPaymentFeeAttribute(): string
    {
        return 'Rp ' . number_format($this->payment_fee, 0, ',', '.');
    }

    public function getFormattedTotalAttribute(): string
    {
        return 'Rp ' . number_format($this->total, 0, ',', '.');
    }

    public function getNetAmountAttribute(): int
    {
        return $this->subtotal - $this->discount - $this->platform_fee;
    }

    public function getFormattedNetAmountAttribute(): string
    {
        return 'Rp ' . number_format($this->net_amount, 0, ',', '.');
    }

    public function getTotalQuantityAttribute(): int
    {
        return $this->items->sum('quantity');
    }

    public function getRemainingTimeAttribute(): ?int
    {
        if (!$this->expires_at || $this->isPaid()) {
            return null;
        }
        
        $remaining = $this->expires_at->diffInSeconds(now(), false);
        return $remaining > 0 ? null : abs($remaining);
    }

    public function getPaymentUrlAttribute(): ?string
    {
        return $this->payment?->xendit_invoice_url;
    }

    // Helpers
    public static function generateOrderNumber(): string
    {
        $prefix = 'NGE';
        $date = now()->format('Ymd');
        $random = strtoupper(substr(md5(uniqid(mt_rand(), true)), 0, 6));
        
        return "{$prefix}{$date}{$random}";
    }
}

======================================================================
FILE: app/Models/OrderItem.php (91 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class OrderItem extends Model
{
    use HasFactory;

    protected $fillable = [
        'order_id',
        'ticket_id',
        'ticket_variant_id',
        'ticket_name',
        'variant_name',
        'quantity',
        'unit_price',
        'subtotal',
    ];

    protected function casts(): array
    {
        return [
            'quantity' => 'integer',
            'unit_price' => 'integer',
            'subtotal' => 'integer',
        ];
    }

    // Relationships
    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    public function ticket(): BelongsTo
    {
        return $this->belongsTo(Ticket::class);
    }

    public function ticketVariant(): BelongsTo
    {
        return $this->belongsTo(TicketVariant::class);
    }

    public function issuedTickets(): HasMany
    {
        return $this->hasMany(IssuedTicket::class);
    }

    // Accessors
    public function getFormattedUnitPriceAttribute(): string
    {
        if ($this->unit_price === 0) {
            return 'Gratis';
        }
        
        return 'Rp ' . number_format($this->unit_price, 0, ',', '.');
    }

    public function getFormattedSubtotalAttribute(): string
    {
        return 'Rp ' . number_format($this->subtotal, 0, ',', '.');
    }

    public function getDisplayNameAttribute(): string
    {
        $parts = [$this->ticket_name];
        
        if ($this->variant_name) {
            $parts[] = $this->variant_name;
        }
        
        return implode(' - ', $parts);
    }

    // Methods
    protected static function boot()
    {
        parent::boot();
        
        static::creating(function ($item) {
            $item->subtotal = $item->unit_price * $item->quantity;
        });
    }
}

======================================================================
FILE: app/Models/Organizer.php (117 lines)
======================================================================
<?php

namespace App\Models;

use App\Traits\HasSlug;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Organizer extends Model
{
    use HasFactory, HasSlug;

    protected $fillable = [
        'user_id',
        'name',
        'slug',
        'logo',
        'banner',
        'bio',
        'website',
        'email',
        'phone',
        'address',
        'city',
        'province',
        'bank_name',
        'bank_account_number',
        'bank_account_name',
        'is_verified',
        'verified_at',
    ];

    protected function casts(): array
    {
        return [
            'is_verified' => 'boolean',
            'verified_at' => 'datetime',
        ];
    }

    protected function slugSource(): string
    {
        return 'name';
    }

    public function getRouteKeyName(): string
    {
        return 'slug';
    }

    // Relationships
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function events(): HasMany
    {
        return $this->hasMany(Event::class);
    }

    public function socialLinks(): HasMany
    {
        return $this->hasMany(OrganizerSocialLink::class);
    }

    public function settlements(): HasMany
    {
        return $this->hasMany(Settlement::class);
    }

    // Accessors
    public function getLogoUrlAttribute(): string
    {
        if ($this->logo) {
            return asset('storage/' . $this->logo);
        }

        return 'https://ui-avatars.com/api/?name=' . urlencode($this->name) . '&background=2563EB&color=fff&size=200';
    }

    public function getBannerUrlAttribute(): ?string
    {
        return $this->banner ? asset('storage/' . $this->banner) : null;
    }

    // Stats
    public function getTotalEventsAttribute(): int
    {
        return $this->events()->count();
    }

    public function getPublishedEventsCountAttribute(): int
    {
        return $this->events()->where('status', 'published')->count();
    }

    public function getTotalTicketsSoldAttribute(): int
    {
        return $this->events()
            ->join('orders', 'events.id', '=', 'orders.event_id')
            ->join('order_items', 'orders.id', '=', 'order_items.order_id')
            ->whereIn('orders.status', ['paid', 'completed'])
            ->sum('order_items.quantity');
    }

    public function getTotalRevenueAttribute(): int
    {
        return $this->events()
            ->join('orders', 'events.id', '=', 'orders.event_id')
            ->whereIn('orders.status', ['paid', 'completed'])
            ->sum('orders.subtotal');
    }
}

======================================================================
FILE: app/Models/OrganizerSocialLink.php (49 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class OrganizerSocialLink extends Model
{
    use HasFactory;

    protected $fillable = [
        'organizer_id',
        'platform',
        'url',
    ];

    public function organizer(): BelongsTo
    {
        return $this->belongsTo(Organizer::class);
    }

    public function getIconAttribute(): string
    {
        return match ($this->platform) {
            'instagram' => 'instagram',
            'twitter' => 'twitter',
            'facebook' => 'facebook',
            'youtube' => 'youtube',
            'tiktok' => 'tiktok',
            'website' => 'globe',
            default => 'link',
        };
    }

    public function getColorAttribute(): string
    {
        return match ($this->platform) {
            'instagram' => '#E4405F',
            'twitter' => '#1DA1F2',
            'facebook' => '#1877F2',
            'youtube' => '#FF0000',
            'tiktok' => '#000000',
            default => '#6B7280',
        };
    }
}

======================================================================
FILE: app/Models/Payment.php (135 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\PaymentStatus;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Payment extends Model
{
    use HasFactory;

    protected $fillable = [
        'order_id',
        'xendit_invoice_id',
        'xendit_invoice_url',
        'xendit_external_id',
        'amount',
        'payment_method',
        'payment_channel',
        'status',
        'paid_at',
        'expires_at',
        'paid_amount',
        'adjusted_received_amount',
        'fees_paid_amount',
        'raw_response',
    ];

    protected function casts(): array
    {
        return [
            'status' => PaymentStatus::class,
            'amount' => 'integer',
            'paid_amount' => 'integer',
            'adjusted_received_amount' => 'integer',
            'fees_paid_amount' => 'integer',
            'paid_at' => 'datetime',
            'expires_at' => 'datetime',
            'raw_response' => 'array',
        ];
    }

    // Relationships
    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    // Status Checks
    public function isPending(): bool
    {
        return $this->status === PaymentStatus::PENDING;
    }

    public function isPaid(): bool
    {
        return $this->status === PaymentStatus::PAID;
    }

    public function isExpired(): bool
    {
        if ($this->status === PaymentStatus::EXPIRED) {
            return true;
        }
        
        return $this->expires_at && $this->expires_at->isPast() && !$this->isPaid();
    }

    public function isFailed(): bool
    {
        return $this->status === PaymentStatus::FAILED;
    }

    public function isRefunded(): bool
    {
        return $this->status === PaymentStatus::REFUNDED;
    }

    // Accessors
    public function getFormattedAmountAttribute(): string
    {
        return 'Rp ' . number_format($this->amount, 0, ',', '.');
    }

    public function getPaymentMethodLabelAttribute(): ?string
    {
        if (!$this->payment_method) {
            return null;
        }

        return match ($this->payment_method) {
            'CREDIT_CARD' => 'Kartu Kredit',
            'BANK_TRANSFER' => 'Transfer Bank',
            'EWALLET' => 'E-Wallet',
            'QR_CODE' => 'QRIS',
            'RETAIL_OUTLET' => 'Retail',
            default => $this->payment_method,
        };
    }

    public function getPaymentChannelLabelAttribute(): ?string
    {
        if (!$this->payment_channel) {
            return null;
        }

        return match ($this->payment_channel) {
            'BCA' => 'BCA',
            'BNI' => 'BNI',
            'BRI' => 'BRI',
            'MANDIRI' => 'Mandiri',
            'PERMATA' => 'Permata',
            'BSI' => 'BSI',
            'OVO' => 'OVO',
            'DANA' => 'DANA',
            'LINKAJA' => 'LinkAja',
            'SHOPEEPAY' => 'ShopeePay',
            'QRIS' => 'QRIS',
            default => $this->payment_channel,
        };
    }

    public function getRemainingTimeAttribute(): ?int
    {
        if (!$this->expires_at || $this->isPaid()) {
            return null;
        }
        
        $remaining = $this->expires_at->diffInSeconds(now(), false);
        return $remaining > 0 ? null : abs($remaining);
    }
}

======================================================================
FILE: app/Models/Subcategory.php (55 lines)
======================================================================
<?php

namespace App\Models;

use App\Traits\HasSlug;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Subcategory extends Model
{
    use HasFactory, HasSlug;

    protected $fillable = [
        'category_id',
        'name',
        'slug',
        'description',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
        ];
    }

    protected function slugSource(): string
    {
        return 'name';
    }

    public function category(): BelongsTo
    {
        return $this->belongsTo(Category::class);
    }

    public function events(): BelongsToMany
    {
        return $this->belongsToMany(Event::class, 'event_subcategory');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeForCategory($query, $categoryId)
    {
        return $query->where('category_id', $categoryId);
    }
}

======================================================================
FILE: app/Models/Ticket.php (140 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\TicketType;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Ticket extends Model
{
    use HasFactory;

    protected $fillable = [
        'event_id',
        'name',
        'description',
        'type',
        'benefits',
        'max_per_order',
        'sort_order',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'type' => TicketType::class,
            'benefits' => 'array',
            'max_per_order' => 'integer',
            'sort_order' => 'integer',
            'is_active' => 'boolean',
        ];
    }

    // Relationships
    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function variants(): HasMany
    {
        return $this->hasMany(TicketVariant::class);
    }

    public function activeVariants(): HasMany
    {
        return $this->variants()
            ->where('is_active', true)
            ->where(function ($query) {
                $query->whereNull('sale_start_at')
                    ->orWhere('sale_start_at', '<=', now());
            })
            ->where(function ($query) {
                $query->whereNull('sale_end_at')
                    ->orWhere('sale_end_at', '>=', now());
            });
    }

    public function availableVariants(): HasMany
    {
        return $this->activeVariants()
            ->whereRaw('stock - sold_count - reserved_count > 0');
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeOrdered($query)
    {
        return $query->orderBy('sort_order');
    }

    // Accessors
    public function getLowestPriceAttribute(): int
    {
        return $this->variants()->where('is_active', true)->min('price') ?? 0;
    }

    public function getHighestPriceAttribute(): int
    {
        return $this->variants()->where('is_active', true)->max('price') ?? 0;
    }

    public function getFormattedPriceAttribute(): string
    {
        if ($this->type === TicketType::FREE) {
            return 'Gratis';
        }

        $lowest = $this->lowest_price;
        $highest = $this->highest_price;

        if ($lowest === $highest || $highest === 0) {
            return 'Rp ' . number_format($lowest, 0, ',', '.');
        }

        return 'Rp ' . number_format($lowest, 0, ',', '.') . ' - Rp ' . number_format($highest, 0, ',', '.');
    }

    public function getTotalStockAttribute(): int
    {
        return $this->variants()->sum('stock');
    }

    public function getTotalSoldAttribute(): int
    {
        return $this->variants()->sum('sold_count');
    }

    public function getTotalAvailableAttribute(): int
    {
        return $this->variants()
            ->where('is_active', true)
            ->selectRaw('SUM(stock - sold_count - reserved_count) as available')
            ->value('available') ?? 0;
    }

    // Checks
    public function hasAvailableStock(): bool
    {
        return $this->total_available > 0;
    }

    public function isFree(): bool
    {
        return $this->type === TicketType::FREE;
    }
}

======================================================================
FILE: app/Models/TicketVariant.php (207 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class TicketVariant extends Model
{
    use HasFactory;

    protected $fillable = [
        'ticket_id',
        'event_day_id',
        'name',
        'price',
        'original_price',
        'stock',
        'sold_count',
        'reserved_count',
        'min_per_order',
        'max_per_order',
        'sale_start_at',
        'sale_end_at',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'price' => 'integer',
            'original_price' => 'integer',
            'stock' => 'integer',
            'sold_count' => 'integer',
            'reserved_count' => 'integer',
            'min_per_order' => 'integer',
            'max_per_order' => 'integer',
            'is_active' => 'boolean',
            'sale_start_at' => 'datetime',
            'sale_end_at' => 'datetime',
        ];
    }

    // Relationships
    public function ticket(): BelongsTo
    {
        return $this->belongsTo(Ticket::class);
    }

    public function eventDay(): BelongsTo
    {
        return $this->belongsTo(EventDay::class);
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeAvailable($query)
    {
        return $query->active()
            ->whereRaw('stock - sold_count - reserved_count > 0')
            ->where(function ($q) {
                $q->whereNull('sale_start_at')
                  ->orWhere('sale_start_at', '<=', now());
            })
            ->where(function ($q) {
                $q->whereNull('sale_end_at')
                  ->orWhere('sale_end_at', '>=', now());
            });
    }

    // Accessors
    public function getAvailableStockAttribute(): int
    {
        return max(0, $this->stock - $this->sold_count - $this->reserved_count);
    }

    public function getFormattedPriceAttribute(): string
    {
        if ($this->price === 0) {
            return 'Gratis';
        }
        
        return 'Rp ' . number_format($this->price, 0, ',', '.');
    }

    public function getFormattedOriginalPriceAttribute(): ?string
    {
        if (!$this->original_price || $this->original_price <= $this->price) {
            return null;
        }
        
        return 'Rp ' . number_format($this->original_price, 0, ',', '.');
    }

    public function getDiscountPercentageAttribute(): ?int
    {
        if (!$this->original_price || $this->original_price <= $this->price) {
            return null;
        }
        
        return (int) round((1 - $this->price / $this->original_price) * 100);
    }

    public function getDisplayNameAttribute(): string
    {
        $parts = [$this->ticket->name];
        
        if ($this->name) {
            $parts[] = $this->name;
        }
        
        if ($this->eventDay) {
            $parts[] = $this->eventDay->short_date;
        }
        
        return implode(' - ', $parts);
    }

    // Checks
    public function isAvailable(): bool
    {
        if (!$this->is_active) {
            return false;
        }
        
        if ($this->available_stock <= 0) {
            return false;
        }
        
        if ($this->sale_start_at && $this->sale_start_at->isFuture()) {
            return false;
        }
        
        if ($this->sale_end_at && $this->sale_end_at->isPast()) {
            return false;
        }
        
        return true;
    }

    public function isOnSale(): bool
    {
        return $this->original_price && $this->original_price > $this->price;
    }

    public function isSoldOut(): bool
    {
        return $this->available_stock <= 0;
    }

    public function isSaleNotStarted(): bool
    {
        return $this->sale_start_at && $this->sale_start_at->isFuture();
    }

    public function isSaleEnded(): bool
    {
        return $this->sale_end_at && $this->sale_end_at->isPast();
    }

    // Methods
    public function canPurchase(int $quantity): bool
    {
        if ($quantity < ($this->min_per_order ?? 1)) {
            return false;
        }
        
        if ($this->max_per_order && $quantity > $this->max_per_order) {
            return false;
        }
        
        return $this->available_stock >= $quantity;
    }

    public function reserve(int $quantity): bool
    {
        if ($this->available_stock < $quantity) {
            return false;
        }
        
        $this->increment('reserved_count', $quantity);
        return true;
    }

    public function releaseReservation(int $quantity): void
    {
        $this->decrement('reserved_count', min($quantity, $this->reserved_count));
    }

    public function confirmSale(int $quantity): void
    {
        $this->decrement('reserved_count', $quantity);
        $this->increment('sold_count', $quantity);
    }
}

======================================================================
FILE: app/Models/User.php (95 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\UserRole;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable implements MustVerifyEmail
{
    use HasApiTokens, HasFactory, Notifiable;

    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'phone',
        'avatar',
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'role' => UserRole::class,
        ];
    }

    // Relationships
    public function organizer(): HasOne
    {
        return $this->hasOne(Organizer::class);
    }

    public function orders(): HasMany
    {
        return $this->hasMany(Order::class);
    }

    public function issuedTickets(): HasMany
    {
        return $this->hasMany(IssuedTicket::class);
    }

    // Role Checks
    public function isAdmin(): bool
    {
        return $this->role === UserRole::ADMIN;
    }

    public function isOrganizer(): bool
    {
        return $this->role === UserRole::ORGANIZER;
    }

    public function isUser(): bool
    {
        return $this->role === UserRole::USER;
    }

    // Accessors
    public function getAvatarUrlAttribute(): string
    {
        if ($this->avatar) {
            return asset('storage/' . $this->avatar);
        }
        
        return 'https://ui-avatars.com/api/?name=' . urlencode($this->name) . '&background=2563EB&color=fff';
    }

    public function getInitialsAttribute(): string
    {
        $words = explode(' ', $this->name);
        $initials = '';
        
        foreach (array_slice($words, 0, 2) as $word) {
            $initials .= strtoupper(substr($word, 0, 1));
        }
        
        return $initials;
    }
}

======================================================================
FILE: app/Models/Voucher.php (248 lines)
======================================================================
<?php

namespace App\Models;

use App\Enums\VoucherType;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Voucher extends Model
{
    use HasFactory;

    protected $fillable = [
        'code',
        'name',
        'description',
        'type',
        'value',
        'min_purchase',
        'max_discount',
        'usage_limit',
        'usage_count',
        'usage_limit_per_user',
        'event_id',
        'category_id',
        'starts_at',
        'expires_at',
        'is_active',
        'created_by',
    ];

    protected function casts(): array
    {
        return [
            'type' => VoucherType::class,
            'value' => 'integer',
            'min_purchase' => 'integer',
            'max_discount' => 'integer',
            'usage_limit' => 'integer',
            'usage_count' => 'integer',
            'usage_limit_per_user' => 'integer',
            'is_active' => 'boolean',
            'starts_at' => 'datetime',
            'expires_at' => 'datetime',
        ];
    }

    // Relationships
    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function category(): BelongsTo
    {
        return $this->belongsTo(Category::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function usages(): HasMany
    {
        return $this->hasMany(VoucherUsage::class);
    }

    public function orders(): HasMany
    {
        return $this->hasMany(Order::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true)
            ->where(function ($q) {
                $q->whereNull('starts_at')
                  ->orWhere('starts_at', '<=', now());
            })
            ->where(function ($q) {
                $q->whereNull('expires_at')
                  ->orWhere('expires_at', '>=', now());
            });
    }

    public function scopeAvailable($query)
    {
        return $query->active()
            ->where(function ($q) {
                $q->whereNull('usage_limit')
                  ->orWhereRaw('usage_count < usage_limit');
            });
    }

    public function scopeForEvent($query, $eventId)
    {
        return $query->where(function ($q) use ($eventId) {
            $q->whereNull('event_id')
              ->orWhere('event_id', $eventId);
        });
    }

    public function scopeForCategory($query, $categoryId)
    {
        return $query->where(function ($q) use ($categoryId) {
            $q->whereNull('category_id')
              ->orWhere('category_id', $categoryId);
        });
    }

    // Checks
    public function isActive(): bool
    {
        if (!$this->is_active) {
            return false;
        }

        if ($this->starts_at && $this->starts_at->isFuture()) {
            return false;
        }

        if ($this->expires_at && $this->expires_at->isPast()) {
            return false;
        }

        return true;
    }

    public function isExpired(): bool
    {
        return $this->expires_at && $this->expires_at->isPast();
    }

    public function hasReachedLimit(): bool
    {
        return $this->usage_limit !== null && $this->usage_count >= $this->usage_limit;
    }

    public function hasUserReachedLimit(int $userId): bool
    {
        if ($this->usage_limit_per_user === null) {
            return false;
        }

        $userUsage = $this->usages()->where('user_id', $userId)->count();
        return $userUsage >= $this->usage_limit_per_user;
    }

    public function isApplicableToEvent(Event $event): bool
    {
        if ($this->event_id && $this->event_id !== $event->id) {
            return false;
        }

        if ($this->category_id && $this->category_id !== $event->category_id) {
            return false;
        }

        return true;
    }

    public function isApplicableToAmount(int $subtotal): bool
    {
        return $this->min_purchase === null || $subtotal >= $this->min_purchase;
    }

    public function canBeUsedBy(int $userId, Event $event, int $subtotal): array
    {
        if (!$this->isActive()) {
            return [false, 'Voucher tidak aktif atau sudah kedaluwarsa'];
        }

        if ($this->hasReachedLimit()) {
            return [false, 'Voucher sudah mencapai batas penggunaan'];
        }

        if ($this->hasUserReachedLimit($userId)) {
            return [false, 'Anda sudah mencapai batas penggunaan voucher ini'];
        }

        if (!$this->isApplicableToEvent($event)) {
            return [false, 'Voucher tidak berlaku untuk event ini'];
        }

        if (!$this->isApplicableToAmount($subtotal)) {
            return [false, 'Minimum pembelian belum tercapai'];
        }

        return [true, null];
    }

    // Calculations
    public function calculateDiscount(int $subtotal): int
    {
        return $this->type->calculateDiscount($subtotal, $this->value, $this->max_discount);
    }

    // Accessors
    public function getFormattedValueAttribute(): string
    {
        return $this->type->formatValue($this->value);
    }

    public function getFormattedMinPurchaseAttribute(): ?string
    {
        if (!$this->min_purchase) {
            return null;
        }
        
        return 'Rp ' . number_format($this->min_purchase, 0, ',', '.');
    }

    public function getFormattedMaxDiscountAttribute(): ?string
    {
        if (!$this->max_discount) {
            return null;
        }
        
        return 'Rp ' . number_format($this->max_discount, 0, ',', '.');
    }

    public function getRemainingUsageAttribute(): ?int
    {
        if ($this->usage_limit === null) {
            return null;
        }
        
        return max(0, $this->usage_limit - $this->usage_count);
    }

    // Methods
    public function incrementUsage(): void
    {
        $this->increment('usage_count');
    }

    public function decrementUsage(): void
    {
        if ($this->usage_count > 0) {
            $this->decrement('usage_count');
        }
    }
}

======================================================================
FILE: app/Models/VoucherUsage.php (49 lines)
======================================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class VoucherUsage extends Model
{
    use HasFactory;

    protected $fillable = [
        'voucher_id',
        'user_id',
        'order_id',
        'discount_amount',
    ];

    protected function casts(): array
    {
        return [
            'discount_amount' => 'integer',
        ];
    }

    // Relationships
    public function voucher(): BelongsTo
    {
        return $this->belongsTo(Voucher::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    // Accessors
    public function getFormattedDiscountAmountAttribute(): string
    {
        return 'Rp ' . number_format($this->discount_amount, 0, ',', '.');
    }
}

======================================================================
FILE: app/Providers/AppServiceProvider.php (25 lines)
======================================================================
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}

======================================================================
FILE: app/Providers/RouteServiceProvider.php (42 lines)
======================================================================
<?php

namespace App\Providers;

use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;

class RouteServiceProvider extends ServiceProvider
{
    /**
     * Define your route model bindings, pattern filters, and other route configuration.
     */
    public function boot(): void
    {
        // API rate limit (60 requests per minute per IP)
        RateLimiter::for('api', function (Request $request) {
            return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
        });

        // Checkout rate limit (prevent spam checkout)
        RateLimiter::for('checkout', function (Request $request) {
            return [
                Limit::perMinute(5)->by($request->ip()), // 5 per minute
                Limit::perHour(20)->by($request->ip()), // 20 per hour
            ];
        });

        // Login rate limit (prevent brute force)
        RateLimiter::for('login', function (Request $request) {
            $email = (string) $request->email;
            return Limit::perMinute(5)->by($email . '|' . $request->ip());
        });

        // Email verification rate limit
        RateLimiter::for('verification', function (Request $request) {
            return Limit::perMinute(3)->by($request->user()?->id ?: $request->ip());
        });
    }
}

======================================================================
FILE: app/Services/ETicketService.php (180 lines)
======================================================================
<?php

namespace App\Services;

use App\Events\TicketIssued;
use App\Models\IssuedTicket;
use App\Models\Order;
use App\Models\OrderItem;
use App\Models\User;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\DB;

class ETicketService
{
    public function generateTickets(Order $order): Collection
    {
        return DB::transaction(function () use ($order) {
            $issuedTickets = collect();

            foreach ($order->items as $item) {
                for ($i = 0; $i < $item->quantity; $i++) {
                    $ticket = $this->createIssuedTicket($item, $order->user);
                    $issuedTickets->push($ticket);
                }
            }

            event(new TicketIssued($order, $issuedTickets));

            return $issuedTickets;
        });
    }

    protected function createIssuedTicket(OrderItem $item, User $user): IssuedTicket
    {
        return IssuedTicket::create([
            'order_item_id' => $item->id,
            'user_id' => $user->id,
            'code' => IssuedTicket::generateCode(),
            'attendee_name' => $item->order->customer_name,
            'attendee_email' => $item->order->customer_email,
            'attendee_phone' => $item->order->customer_phone,
        ]);
    }

    public function getTicketByCode(string $code): ?IssuedTicket
    {
        return IssuedTicket::with([
            'orderItem.order.event',
            'orderItem.ticket',
            'orderItem.ticketVariant.eventDay',
        ])->where('code', $code)->first();
    }

    public function checkIn(IssuedTicket $ticket, ?User $checkedInBy = null, ?string $notes = null): bool
    {
        if ($ticket->is_used) {
            return false;
        }

        return $ticket->markAsUsed($checkedInBy?->id, $notes);
    }

    public function undoCheckIn(IssuedTicket $ticket): bool
    {
        if (!$ticket->is_used) {
            return false;
        }

        return $ticket->resetUsage();
    }

    public function validateTicket(string $code, int $eventId): array
    {
        $ticket = $this->getTicketByCode($code);

        if (!$ticket) {
            return [
                'valid' => false,
                'message' => 'Tiket tidak ditemukan',
                'ticket' => null,
            ];
        }

        $order = $ticket->orderItem->order;

        if ($order->event_id !== $eventId) {
            return [
                'valid' => false,
                'message' => 'Tiket bukan untuk event ini',
                'ticket' => null,
            ];
        }

        if (!$order->isPaid()) {
            return [
                'valid' => false,
                'message' => 'Pembayaran belum selesai',
                'ticket' => null,
            ];
        }

        if ($ticket->is_used) {
            return [
                'valid' => false,
                'message' => 'Tiket sudah digunakan pada ' . $ticket->used_at->format('d M Y H:i'),
                'ticket' => $ticket,
            ];
        }

        return [
            'valid' => true,
            'message' => 'Tiket valid',
            'ticket' => $ticket,
        ];
    }

    public function getUserTickets(User $user): Collection
    {
        return IssuedTicket::query()
            ->with([
                'orderItem.order.event',
                'orderItem.ticket',
                'orderItem.ticketVariant.eventDay',
            ])
            ->where('user_id', $user->id)
            ->whereHas('orderItem.order', fn($q) => $q->whereIn('status', ['paid', 'completed']))
            ->latest()
            ->get();
    }

    public function getEventAttendees(int $eventId, array $filters = []): Collection
    {
        $query = IssuedTicket::query()
            ->with(['orderItem.ticket', 'orderItem.ticketVariant.eventDay', 'user'])
            ->whereHas('orderItem.order', fn($q) => $q->where('event_id', $eventId)->whereIn('status', ['paid', 'completed']));

        if (isset($filters['is_used'])) {
            $query->where('is_used', $filters['is_used']);
        }

        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $query->where(function ($q) use ($search) {
                $q->where('code', 'ilike', "%{$search}%")
                    ->orWhere('attendee_name', 'ilike', "%{$search}%")
                    ->orWhere('attendee_email', 'ilike', "%{$search}%");
            });
        }

        if (!empty($filters['ticket_id'])) {
            $query->whereHas('orderItem', fn($q) => $q->where('ticket_id', $filters['ticket_id']));
        }

        return $query->orderBy('created_at')->get();
    }

    public function getCheckInStats(int $eventId): array
    {
        $tickets = IssuedTicket::query()
            ->whereHas('orderItem.order', fn($q) => $q->where('event_id', $eventId)->whereIn('status', ['paid', 'completed']))
            ->get();

        $total = $tickets->count();
        $checkedIn = $tickets->where('is_used', true)->count();

        return [
            'total' => $total,
            'checked_in' => $checkedIn,
            'remaining' => $total - $checkedIn,
            'percentage' => $total > 0 ? round(($checkedIn / $total) * 100, 1) : 0,
        ];
    }

    public function bulkUpdateAttendeeInfo(array $ticketIds, array $data): int
    {
        return IssuedTicket::whereIn('id', $ticketIds)
            ->update(collect($data)->only(['attendee_name', 'attendee_email', 'attendee_phone'])->toArray());
    }
}

======================================================================
FILE: app/Services/EventService.php (272 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\EventStatus;
use App\Models\Event;
use App\Models\EventDay;
use App\Models\Organizer;
use App\Models\User;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class EventService
{
    public function __construct(
        private TicketService $ticketService,
    ) {}

    public function getPublishedEvents(array $filters = [], int $perPage = 12): LengthAwarePaginator
    {
        $query = Event::query()
            ->with(['organizer', 'category', 'subcategories'])
            ->published()
            ->upcoming();

        if (!empty($filters['category'])) {
            $query->where('category_id', $filters['category']);
        }

        if (!empty($filters['city'])) {
            $query->where('city', $filters['city']);
        }

        if (!empty($filters['search'])) {
            $query->search($filters['search']);
        }

        if (!empty($filters['date_from'])) {
            $query->where('start_date', '>=', $filters['date_from']);
        }

        if (!empty($filters['date_to'])) {
            $query->where('start_date', '<=', $filters['date_to']);
        }

        if (!empty($filters['is_free'])) {
            $query->where('is_free', true);
        }

        $sortBy = $filters['sort'] ?? 'date';
        match ($sortBy) {
            'popular' => $query->orderByDesc('views_count'),
            'price_low' => $query->orderBy('min_price'),
            'price_high' => $query->orderByDesc('max_price'),
            default => $query->orderBy('start_date'),
        };

        return $query->paginate($perPage);
    }

    public function getFeaturedEvents(int $limit = 6): Collection
    {
        return Event::query()
            ->with(['organizer', 'category'])
            ->published()
            ->upcoming()
            ->featured()
            ->orderBy('start_date')
            ->limit($limit)
            ->get();
    }

    public function getEventForDisplay(string $slug): ?Event
    {
        $event = Event::query()
            ->with(['organizer.socialLinks', 'category', 'subcategories', 'days', 'tickets.activeVariants.eventDay'])
            ->where('slug', $slug)
            ->whereIn('status', EventStatus::publicStatuses())
            ->first();

        if ($event) {
            $event->incrementViews();
        }

        return $event;
    }

    public function create(Organizer $organizer, array $data): Event
    {
        return DB::transaction(function () use ($organizer, $data) {
            $posterPath = isset($data['poster']) ? $data['poster']->store('events/posters', 'public') : null;
            $bannerPath = isset($data['banner']) ? $data['banner']->store('events/banners', 'public') : null;
            $proposalPath = isset($data['proposal_file']) ? $data['proposal_file']->store('events/proposals', 'public') : null;

            $event = Event::create([
                'organizer_id' => $organizer->id,
                'category_id' => $data['category_id'],
                'title' => $data['title'],
                'description' => $data['description'] ?? null,
                'short_description' => $data['short_description'] ?? null,
                'poster' => $posterPath,
                'banner' => $bannerPath,
                'start_date' => $data['start_date'],
                'end_date' => $data['end_date'],
                'start_time' => $data['start_time'] ?? null,
                'end_time' => $data['end_time'] ?? null,
                'venue_name' => $data['venue_name'] ?? null,
                'venue_address' => $data['venue_address'] ?? null,
                'city' => $data['city'] ?? null,
                'province' => $data['province'] ?? null,
                'is_online' => $data['is_online'] ?? false,
                'online_url' => $data['online_url'] ?? null,
                'is_free' => $data['is_free'] ?? false,
                'proposal_file' => $proposalPath,
                'status' => EventStatus::DRAFT,
            ]);

            if (!empty($data['subcategories'])) {
                $event->subcategories()->sync($data['subcategories']);
            }

            $this->createEventDays($event, $data);

            return $event;
        });
    }

    public function update(Event $event, array $data): Event
    {
        return DB::transaction(function () use ($event, $data) {
            $updateData = collect($data)->only([
                'category_id', 'title', 'description', 'short_description',
                'start_date', 'end_date', 'start_time', 'end_time',
                'venue_name', 'venue_address', 'city', 'province',
                'is_online', 'online_url', 'is_free',
            ])->toArray();

            if (isset($data['poster'])) {
                if ($event->poster) Storage::disk('public')->delete($event->poster);
                $updateData['poster'] = $data['poster']->store('events/posters', 'public');
            }

            if (isset($data['banner'])) {
                if ($event->banner) Storage::disk('public')->delete($event->banner);
                $updateData['banner'] = $data['banner']->store('events/banners', 'public');
            }

            $event->update($updateData);

            if (isset($data['subcategories'])) {
                $event->subcategories()->sync($data['subcategories']);
            }

            return $event->fresh();
        });
    }

    public function submitForReview(Event $event): bool
    {
        if ($event->status !== EventStatus::DRAFT) return false;
        return $event->update(['status' => EventStatus::PENDING_REVIEW]);
    }

    public function approve(Event $event, User $admin, ?string $notes = null): bool
    {
        if ($event->status !== EventStatus::PENDING_REVIEW) return false;
        return $event->update([
            'status' => EventStatus::APPROVED,
            'approved_at' => now(),
            'approved_by' => $admin->id,
            'admin_notes' => $notes,
        ]);
    }

    public function reject(Event $event, User $admin, string $reason): bool
    {
        if ($event->status !== EventStatus::PENDING_REVIEW) return false;
        return $event->update([
            'status' => EventStatus::DRAFT,
            'rejection_reason' => $reason,
        ]);
    }

    public function publish(Event $event): bool
    {
        if ($event->status !== EventStatus::APPROVED) return false;
        $event->updatePriceRange();
        return $event->update(['status' => EventStatus::PUBLISHED, 'published_at' => now()]);
    }

    public function unpublish(Event $event): bool
    {
        if ($event->status !== EventStatus::PUBLISHED) return false;
        return $event->update(['status' => EventStatus::APPROVED, 'published_at' => null]);
    }

    public function cancel(Event $event, string $reason): bool
    {
        if (in_array($event->status, [EventStatus::CANCELLED, EventStatus::COMPLETED])) return false;
        return $event->update(['status' => EventStatus::CANCELLED, 'admin_notes' => "Cancelled: {$reason}"]);
    }

    public function complete(Event $event): bool
    {
        if ($event->status !== EventStatus::PUBLISHED) return false;
        return $event->update(['status' => EventStatus::COMPLETED]);
    }

    protected function createEventDays(Event $event, array $data): void
    {
        if (!$event->isMultiDay()) {
            EventDay::create([
                'event_id' => $event->id,
                'date' => $event->start_date,
                'start_time' => $event->start_time,
                'end_time' => $event->end_time,
            ]);
            return;
        }

        if (!empty($data['days'])) {
            foreach ($data['days'] as $dayData) {
                EventDay::create([
                    'event_id' => $event->id,
                    'date' => $dayData['date'],
                    'name' => $dayData['name'] ?? null,
                    'start_time' => $dayData['start_time'] ?? null,
                    'end_time' => $dayData['end_time'] ?? null,
                ]);
            }
        } else {
            $currentDate = $event->start_date->copy();
            $dayNumber = 1;
            while ($currentDate->lte($event->end_date)) {
                EventDay::create([
                    'event_id' => $event->id,
                    'date' => $currentDate->toDateString(),
                    'name' => "Day {$dayNumber}",
                ]);
                $currentDate->addDay();
                $dayNumber++;
            }
        }
    }

    public function getOrganizerEvents(Organizer $organizer, array $filters = []): LengthAwarePaginator
    {
        $query = Event::where('organizer_id', $organizer->id)->with(['category']);
        if (!empty($filters['status'])) $query->where('status', $filters['status']);
        if (!empty($filters['search'])) $query->search($filters['search']);
        return $query->latest()->paginate(10);
    }

    public function getPendingReviewEvents(): Collection
    {
        return Event::with(['organizer', 'category'])
            ->where('status', EventStatus::PENDING_REVIEW)
            ->oldest()
            ->get();
    }

    public function getEventCities(): Collection
    {
        return Event::published()->upcoming()
            ->whereNotNull('city')
            ->distinct()
            ->pluck('city');
    }
}

======================================================================
FILE: app/Services/OrderService.php (305 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\OrderStatus;
use App\Enums\PaymentStatus;
use App\Events\OrderCreated;
use App\Events\OrderPaid;
use App\Events\OrderExpired;
use App\Events\OrderRefunded;
use App\Exceptions\InsufficientTicketException;
use App\Models\Event;
use App\Models\Order;
use App\Models\OrderItem;
use App\Models\TicketVariant;
use App\Models\User;
use App\Models\Voucher;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class OrderService
{
    public function __construct(
        private TicketService $ticketService,
        private VoucherService $voucherService,
        private PaymentService $paymentService,
    ) {}

    public function create(User $user, Event $event, array $items, array $customerData, ?Voucher $voucher = null): Order
    {
        return DB::transaction(function () use ($user, $event, $items, $customerData, $voucher) {
            // Reserve stock for all items
            foreach ($items as $item) {
                $this->ticketService->reserveStock($item['ticket_variant_id'], $item['quantity']);
            }

            // Calculate totals
            $totals = $this->calculateTotals($items, $voucher);

            // Create order
            $order = Order::create([
                'order_number' => $this->generateOrderNumber(),
                'user_id' => $user->id,
                'event_id' => $event->id,
                'voucher_id' => $voucher?->id,
                'customer_name' => $customerData['name'],
                'customer_email' => $customerData['email'],
                'customer_phone' => $customerData['phone'] ?? null,
                'subtotal' => $totals['subtotal'],
                'discount' => $totals['discount'],
                'platform_fee' => $totals['platform_fee'],
                'payment_fee' => $totals['payment_fee'],
                'total' => $totals['total'],
                'status' => OrderStatus::PENDING,
                'expires_at' => now()->addMinutes(config('ngevent.order_expiry_minutes', 15)),
            ]);

            // Create order items
            foreach ($items as $item) {
                $variant = TicketVariant::with('ticket')->find($item['ticket_variant_id']);

                OrderItem::create([
                    'order_id' => $order->id,
                    'ticket_id' => $variant->ticket_id,
                    'ticket_variant_id' => $variant->id,
                    'ticket_name' => $variant->ticket->name,
                    'variant_name' => $variant->name,
                    'quantity' => $item['quantity'],
                    'unit_price' => $variant->price,
                    'subtotal' => $variant->price * $item['quantity'],
                ]);
            }

            // Record voucher usage
            if ($voucher) {
                $this->voucherService->recordUsage($voucher, $user, $order, $totals['discount']);
            }

            // Create payment invoice
            $payment = $this->paymentService->createInvoice($order);

            // Update order status
            $order->update(['status' => OrderStatus::AWAITING_PAYMENT]);

            event(new OrderCreated($order));

            return $order->fresh(['items', 'payment']);
        });
    }

    public function calculateTotals(array $items, ?Voucher $voucher = null): array
    {
        $subtotal = 0;

        foreach ($items as $item) {
            $variant = TicketVariant::find($item['ticket_variant_id']);
            $subtotal += $variant->price * $item['quantity'];
        }

        $discount = 0;
        if ($voucher) {
            $discount = $voucher->calculateDiscount($subtotal);
        }

        $afterDiscount = $subtotal - $discount;

        $platformFeeRate = config('ngevent.platform_fee_percentage', 5) / 100;
        $paymentFeeRate = config('ngevent.payment_fee_percentage', 2.5) / 100;

        $platformFee = (int) ceil($afterDiscount * $platformFeeRate);
        $paymentFee = (int) ceil($afterDiscount * $paymentFeeRate);

        $total = $afterDiscount + $paymentFee;

        return [
            'subtotal' => $subtotal,
            'discount' => $discount,
            'platform_fee' => $platformFee,
            'payment_fee' => $paymentFee,
            'total' => $total,
            'net_amount' => $afterDiscount - $platformFee, // Amount organizer receives
        ];
    }

    public function markAsPaid(Order $order): Order
    {
        return DB::transaction(function () use ($order) {
            $order->update([
                'status' => OrderStatus::PAID,
                'paid_at' => now(),
            ]);

            // Confirm stock sales
            foreach ($order->items as $item) {
                $this->ticketService->confirmSale($item->ticket_variant_id, $item->quantity);
            }

            event(new OrderPaid($order));

            return $order->fresh();
        });
    }

    public function expire(Order $order): Order
    {
        if ($order->isPaid()) {
            return $order;
        }

        return DB::transaction(function () use ($order) {
            $order->update(['status' => OrderStatus::EXPIRED]);

            // Release reserved stock
            foreach ($order->items as $item) {
                $this->ticketService->releaseStock($item->ticket_variant_id, $item->quantity);
            }

            // Release voucher usage
            if ($order->voucher_id) {
                $this->voucherService->releaseUsage($order);
            }

            event(new OrderExpired($order));

            return $order->fresh();
        });
    }

    public function cancel(Order $order, string $reason): Order
    {
        if (!$order->canCancel()) {
            return $order;
        }

        return DB::transaction(function () use ($order, $reason) {
            $order->update([
                'status' => OrderStatus::CANCELLED,
                'cancelled_at' => now(),
                'cancellation_reason' => $reason,
            ]);

            // Release reserved stock
            foreach ($order->items as $item) {
                $this->ticketService->releaseStock($item->ticket_variant_id, $item->quantity);
            }

            // Release voucher usage
            if ($order->voucher_id) {
                $this->voucherService->releaseUsage($order);
            }

            return $order->fresh();
        });
    }

    public function refund(Order $order, string $reason): Order
    {
        if (!$order->canRefund()) {
            return $order;
        }

        return DB::transaction(function () use ($order, $reason) {
            $order->update([
                'status' => OrderStatus::REFUNDED,
                'cancellation_reason' => $reason,
            ]);

            // Return sold stock
            foreach ($order->items as $item) {
                $this->ticketService->returnStock($item->ticket_variant_id, $item->quantity);
            }

            // Invalidate issued tickets
            $order->issuedTickets()->update(['is_used' => true, 'check_in_notes' => 'Order refunded']);

            // Update payment status
            $order->payment?->update(['status' => PaymentStatus::REFUNDED]);

            event(new OrderRefunded($order));

            return $order->fresh();
        });
    }

    public function complete(Order $order): Order
    {
        if ($order->status !== OrderStatus::PAID) {
            return $order;
        }

        return DB::transaction(function () use ($order) {
            $order->update([
                'status' => OrderStatus::COMPLETED,
                'completed_at' => now(),
            ]);

            return $order->fresh();
        });
    }

    public function getUserOrders(User $user, int $perPage = 10): LengthAwarePaginator
    {
        return Order::query()
            ->where('user_id', $user->id)
            ->with(['event', 'items', 'payment'])
            ->latest()
            ->paginate($perPage);
    }

    public function getEventOrders(Event $event, array $filters = []): LengthAwarePaginator
    {
        $query = Order::query()
            ->where('event_id', $event->id)
            ->with(['user', 'items']);

        if (!empty($filters['status'])) {
            $query->where('status', $filters['status']);
        }

        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $query->where(function ($q) use ($search) {
                $q->where('order_number', 'ilike', "%{$search}%")
                    ->orWhere('customer_name', 'ilike', "%{$search}%")
                    ->orWhere('customer_email', 'ilike', "%{$search}%");
            });
        }

        return $query->latest()->paginate(20);
    }

    public function getOrderByNumber(string $orderNumber): ?Order
    {
        return Order::where('order_number', $orderNumber)
            ->with(['event', 'items.ticket', 'items.ticketVariant', 'payment', 'issuedTickets'])
            ->first();
    }

    public function getExpiredOrders(): Collection
    {
        return Order::query()
            ->whereIn('status', [OrderStatus::PENDING, OrderStatus::AWAITING_PAYMENT])
            ->where('expires_at', '<', now())
            ->get();
    }

    protected function generateOrderNumber(): string
    {
        $prefix = 'NGE';
        $date = now()->format('Ymd');
        $random = strtoupper(Str::random(6));

        $orderNumber = "{$prefix}{$date}{$random}";

        while (Order::where('order_number', $orderNumber)->exists()) {
            $random = strtoupper(Str::random(6));
            $orderNumber = "{$prefix}{$date}{$random}";
        }

        return $orderNumber;
    }
}

======================================================================
FILE: app/Services/PaymentService.php (211 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\OrderStatus;
use App\Enums\PaymentStatus;
use App\Exceptions\PaymentFailedException;
use App\Models\Order;
use App\Models\Payment;
use App\Services\Xendit\XenditClient;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class PaymentService
{
    public function __construct(
        private XenditClient $xenditClient,
        private OrderService $orderService,
    ) {}

    public function createInvoice(Order $order): Payment
    {
        try {
            $externalId = "order-{$order->order_number}";

            $items = $order->items->map(fn($item) => [
                'name' => $item->display_name,
                'quantity' => $item->quantity,
                'price' => $item->unit_price,
            ])->toArray();

            // Add fees as line items
            if ($order->payment_fee > 0) {
                $items[] = [
                    'name' => 'Biaya Pembayaran',
                    'quantity' => 1,
                    'price' => $order->payment_fee,
                ];
            }

            $response = $this->xenditClient->createInvoice([
                'external_id' => $externalId,
                'amount' => $order->total,
                'payer_email' => $order->customer_email,
                'description' => "Pembayaran tiket {$order->event->title}",
                'invoice_duration' => config('xendit.invoice_duration', 900),
                'customer' => [
                    'given_names' => $order->customer_name,
                    'email' => $order->customer_email,
                    'mobile_number' => $order->customer_phone,
                ],
                'items' => $items,
                'success_redirect_url' => route('checkout.success', $order),
                'failure_redirect_url' => route('checkout.failed', $order),
                'currency' => 'IDR',
            ]);

            return Payment::create([
                'order_id' => $order->id,
                'xendit_invoice_id' => $response['id'],
                'xendit_invoice_url' => $response['invoice_url'],
                'xendit_external_id' => $externalId,
                'amount' => $order->total,
                'status' => PaymentStatus::PENDING,
                'expires_at' => now()->addSeconds(config('xendit.invoice_duration', 900)),
                'raw_response' => $response,
            ]);

        } catch (\Exception $e) {
            Log::channel('payment')->error('Failed to create invoice', [
                'order_id' => $order->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentFailedException(
                $order->id,
                'invoice_creation_failed',
                'Gagal membuat invoice pembayaran'
            );
        }
    }

    public function handleWebhook(array $payload): void
    {
        $invoiceId = $payload['id'] ?? null;
        $status = $payload['status'] ?? null;

        if (!$invoiceId || !$status) {
            Log::channel('webhook')->warning('Invalid webhook payload', $payload);
            return;
        }

        $payment = Payment::where('xendit_invoice_id', $invoiceId)->first();

        if (!$payment) {
            Log::channel('webhook')->warning('Payment not found for invoice', ['invoice_id' => $invoiceId]);
            return;
        }

        // Idempotency check
        if ($payment->status->isFinal()) {
            Log::channel('webhook')->info('Payment already in final state', [
                'invoice_id' => $invoiceId,
                'status' => $payment->status->value,
            ]);
            return;
        }

        DB::transaction(function () use ($payment, $payload, $status) {
            match ($status) {
                'PAID', 'SETTLED' => $this->handlePaid($payment, $payload),
                'EXPIRED' => $this->handleExpired($payment),
                default => Log::channel('webhook')->info('Unhandled status', ['status' => $status]),
            };
        });
    }

    protected function handlePaid(Payment $payment, array $payload): void
    {
        $payment->update([
            'status' => PaymentStatus::PAID,
            'paid_at' => now(),
            'payment_method' => $payload['payment_method'] ?? null,
            'payment_channel' => $payload['payment_channel'] ?? null,
            'paid_amount' => $payload['paid_amount'] ?? null,
            'adjusted_received_amount' => $payload['adjusted_received_amount'] ?? null,
            'fees_paid_amount' => $payload['fees_paid_amount'] ?? null,
            'raw_response' => $payload,
        ]);

        // Mark order as paid
        app(OrderService::class)->markAsPaid($payment->order);

        Log::channel('payment')->info('Payment successful', [
            'order_id' => $payment->order_id,
            'invoice_id' => $payment->xendit_invoice_id,
            'amount' => $payment->amount,
        ]);
    }

    protected function handleExpired(Payment $payment): void
    {
        $payment->update(['status' => PaymentStatus::EXPIRED]);

        // Expire the order
        app(OrderService::class)->expire($payment->order);

        Log::channel('payment')->info('Payment expired', [
            'order_id' => $payment->order_id,
            'invoice_id' => $payment->xendit_invoice_id,
        ]);
    }

    public function getPaymentStatus(Order $order): ?Payment
    {
        return $order->payment;
    }

    public function refreshPaymentStatus(Payment $payment): Payment
    {
        try {
            $response = $this->xenditClient->getInvoice($payment->xendit_invoice_id);

            $status = match ($response['status']) {
                'PAID', 'SETTLED' => PaymentStatus::PAID,
                'EXPIRED' => PaymentStatus::EXPIRED,
                'PENDING' => PaymentStatus::PENDING,
                default => $payment->status,
            };

            if ($status !== $payment->status) {
                $payment->update([
                    'status' => $status,
                    'raw_response' => $response,
                ]);

                if ($status === PaymentStatus::PAID) {
                    $this->handlePaid($payment, $response);
                } elseif ($status === PaymentStatus::EXPIRED) {
                    $this->handleExpired($payment);
                }
            }

            return $payment->fresh();

        } catch (\Exception $e) {
            Log::channel('payment')->error('Failed to refresh payment status', [
                'payment_id' => $payment->id,
                'error' => $e->getMessage(),
            ]);

            return $payment;
        }
    }

    public function expireInvoice(Payment $payment): bool
    {
        try {
            $this->xenditClient->expireInvoice($payment->xendit_invoice_id);
            $this->handleExpired($payment);
            return true;
        } catch (\Exception $e) {
            Log::channel('payment')->error('Failed to expire invoice', [
                'payment_id' => $payment->id,
                'error' => $e->getMessage(),
            ]);
            return false;
        }
    }
}

======================================================================
FILE: app/Services/SettlementService.php (222 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\EventStatus;
use App\Enums\OrderStatus;
use App\Enums\SettlementStatus;
use App\Events\SettlementProcessed;
use App\Models\Event;
use App\Models\Organizer;
use App\Models\Settlement;
use App\Models\User;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class SettlementService
{
    public function createForEvent(Event $event): Settlement
    {
        $organizer = $event->organizer;
        $calculation = $this->calculate($event);

        return Settlement::create([
            'event_id' => $event->id,
            'organizer_id' => $organizer->id,
            'gross_amount' => $calculation['gross_amount'],
            'platform_fee' => $calculation['platform_fee'],
            'payment_fee_total' => $calculation['payment_fee_total'],
            'refund_amount' => $calculation['refund_amount'],
            'net_amount' => $calculation['net_amount'],
            'bank_name' => $organizer->bank_name,
            'bank_account_number' => $organizer->bank_account_number,
            'bank_account_name' => $organizer->bank_account_name,
            'status' => SettlementStatus::PENDING,
        ]);
    }

    public function calculate(Event $event): array
    {
        $paidOrders = $event->orders()
            ->whereIn('status', [OrderStatus::PAID, OrderStatus::COMPLETED])
            ->get();

        $refundedOrders = $event->orders()
            ->where('status', OrderStatus::REFUNDED)
            ->get();

        $grossAmount = $paidOrders->sum('subtotal') - $paidOrders->sum('discount');
        $platformFee = $paidOrders->sum('platform_fee');
        $paymentFeeTotal = $paidOrders->sum('payment_fee');
        $refundAmount = $refundedOrders->sum('subtotal') - $refundedOrders->sum('discount');
        $netAmount = $grossAmount - $platformFee - $refundAmount;

        return [
            'gross_amount' => max(0, $grossAmount),
            'platform_fee' => max(0, $platformFee),
            'payment_fee_total' => max(0, $paymentFeeTotal),
            'refund_amount' => max(0, $refundAmount),
            'net_amount' => max(0, $netAmount),
            'total_orders' => $paidOrders->count(),
            'total_tickets' => $paidOrders->sum(fn($o) => $o->items->sum('quantity')),
        ];
    }

    public function process(Settlement $settlement, User $admin): Settlement
    {
        if (!$settlement->canProcess()) {
            return $settlement;
        }

        $settlement->update([
            'status' => SettlementStatus::PROCESSING,
            'processed_by' => $admin->id,
        ]);

        return $settlement->fresh();
    }

    public function markAsTransferred(
        Settlement $settlement,
        string $reference,
        ?string $proofPath = null,
        ?string $notes = null
    ): Settlement {
        return DB::transaction(function () use ($settlement, $reference, $proofPath, $notes) {
            $settlement->update([
                'status' => SettlementStatus::TRANSFERRED,
                'transfer_reference' => $reference,
                'transfer_proof' => $proofPath,
                'transferred_at' => now(),
                'notes' => $notes,
            ]);

            event(new SettlementProcessed($settlement));

            Log::channel('payment')->info('Settlement transferred', [
                'settlement_id' => $settlement->id,
                'event_id' => $settlement->event_id,
                'amount' => $settlement->net_amount,
                'reference' => $reference,
            ]);

            return $settlement->fresh();
        });
    }

    public function markAsFailed(Settlement $settlement, string $reason): Settlement
    {
        $settlement->update([
            'status' => SettlementStatus::FAILED,
            'admin_notes' => $reason,
        ]);

        return $settlement->fresh();
    }

    public function retry(Settlement $settlement, User $admin): Settlement
    {
        if (!$settlement->canRetry()) {
            return $settlement;
        }

        $settlement->update([
            'status' => SettlementStatus::PENDING,
            'admin_notes' => null,
        ]);

        return $this->process($settlement, $admin);
    }

    public function getPendingSettlements(): Collection
    {
        return Settlement::query()
            ->with(['event', 'organizer'])
            ->where('status', SettlementStatus::PENDING)
            ->orderBy('created_at')
            ->get();
    }

    public function getAll(array $filters = []): LengthAwarePaginator
    {
        $query = Settlement::query()->with(['event', 'organizer']);

        if (!empty($filters['status'])) {
            $query->where('status', $filters['status']);
        }

        if (!empty($filters['organizer_id'])) {
            $query->where('organizer_id', $filters['organizer_id']);
        }

        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $query->whereHas('event', fn($q) => $q->where('title', 'ilike', "%{$search}%"))
                ->orWhereHas('organizer', fn($q) => $q->where('name', 'ilike', "%{$search}%"));
        }

        return $query->latest()->paginate(20);
    }

    public function getOrganizerSettlements(Organizer $organizer): LengthAwarePaginator
    {
        return Settlement::query()
            ->with(['event'])
            ->where('organizer_id', $organizer->id)
            ->latest()
            ->paginate(10);
    }

    public function getEventsReadyForSettlement(): Collection
    {
        $delayDays = config('ngevent.settlement_delay_days', 7);

        return Event::query()
            ->with(['organizer'])
            ->where('status', EventStatus::COMPLETED)
            ->where('end_date', '<=', now()->subDays($delayDays))
            ->whereDoesntHave('settlement')
            ->whereHas('orders', fn($q) => $q->whereIn('status', [OrderStatus::PAID, OrderStatus::COMPLETED]))
            ->get();
    }

    public function processReadySettlements(): int
    {
        $events = $this->getEventsReadyForSettlement();
        $count = 0;

        foreach ($events as $event) {
            try {
                $this->createForEvent($event);
                $count++;

                Log::channel('payment')->info('Settlement created for event', [
                    'event_id' => $event->id,
                    'event_title' => $event->title,
                ]);
            } catch (\Exception $e) {
                Log::channel('payment')->error('Failed to create settlement', [
                    'event_id' => $event->id,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        return $count;
    }

    public function getSettlementStats(): array
    {
        return [
            'pending_count' => Settlement::where('status', SettlementStatus::PENDING)->count(),
            'pending_amount' => Settlement::where('status', SettlementStatus::PENDING)->sum('net_amount'),
            'processing_count' => Settlement::where('status', SettlementStatus::PROCESSING)->count(),
            'transferred_this_month' => Settlement::where('status', SettlementStatus::TRANSFERRED)
                ->whereMonth('transferred_at', now()->month)
                ->sum('net_amount'),
        ];
    }
}

======================================================================
FILE: app/Services/TicketService.php (198 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\TicketType;
use App\Exceptions\InsufficientTicketException;
use App\Models\Event;
use App\Models\Ticket;
use App\Models\TicketVariant;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\DB;

class TicketService
{
    public function create(Event $event, array $data): Ticket
    {
        return DB::transaction(function () use ($event, $data) {
            $ticket = Ticket::create([
                'event_id' => $event->id,
                'name' => $data['name'],
                'description' => $data['description'] ?? null,
                'type' => $data['type'] ?? TicketType::REGULAR,
                'benefits' => $data['benefits'] ?? null,
                'max_per_order' => $data['max_per_order'] ?? 10,
                'sort_order' => $data['sort_order'] ?? 0,
                'is_active' => $data['is_active'] ?? true,
            ]);

            if (!empty($data['variants'])) {
                foreach ($data['variants'] as $variantData) {
                    $this->createVariant($ticket, $variantData);
                }
            }

            $event->updatePriceRange();

            return $ticket;
        });
    }

    public function update(Ticket $ticket, array $data): Ticket
    {
        $ticket->update(collect($data)->only([
            'name', 'description', 'type', 'benefits', 'max_per_order', 'sort_order', 'is_active'
        ])->toArray());

        $ticket->event->updatePriceRange();

        return $ticket->fresh();
    }

    public function delete(Ticket $ticket): bool
    {
        if ($ticket->orderItems()->exists()) {
            return false;
        }

        $event = $ticket->event;
        $ticket->delete();
        $event->updatePriceRange();

        return true;
    }

    public function createVariant(Ticket $ticket, array $data): TicketVariant
    {
        $variant = TicketVariant::create([
            'ticket_id' => $ticket->id,
            'event_day_id' => $data['event_day_id'] ?? null,
            'name' => $data['name'] ?? null,
            'price' => $data['price'] ?? 0,
            'original_price' => $data['original_price'] ?? null,
            'stock' => $data['stock'] ?? 0,
            'min_per_order' => $data['min_per_order'] ?? 1,
            'max_per_order' => $data['max_per_order'] ?? null,
            'sale_start_at' => $data['sale_start_at'] ?? null,
            'sale_end_at' => $data['sale_end_at'] ?? null,
            'is_active' => $data['is_active'] ?? true,
        ]);

        $ticket->event->updatePriceRange();

        return $variant;
    }

    public function updateVariant(TicketVariant $variant, array $data): TicketVariant
    {
        $variant->update(collect($data)->only([
            'event_day_id', 'name', 'price', 'original_price', 'stock',
            'min_per_order', 'max_per_order', 'sale_start_at', 'sale_end_at', 'is_active'
        ])->toArray());

        $variant->ticket->event->updatePriceRange();

        return $variant->fresh();
    }

    public function deleteVariant(TicketVariant $variant): bool
    {
        if ($variant->orderItems()->exists()) {
            return false;
        }

        $event = $variant->ticket->event;
        $variant->delete();
        $event->updatePriceRange();

        return true;
    }

    public function getAvailableVariants(Event $event): Collection
    {
        return TicketVariant::query()
            ->whereHas('ticket', fn($q) => $q->where('event_id', $event->id)->where('is_active', true))
            ->available()
            ->with(['ticket', 'eventDay'])
            ->get();
    }

    public function checkAvailability(int $variantId, int $quantity): bool
    {
        $variant = TicketVariant::find($variantId);

        if (!$variant || !$variant->isAvailable()) {
            return false;
        }

        return $variant->available_stock >= $quantity;
    }

    public function reserveStock(int $variantId, int $quantity): void
    {
        $variant = TicketVariant::lockForUpdate()->findOrFail($variantId);

        if ($variant->available_stock < $quantity) {
            throw new InsufficientTicketException(
                $variantId,
                $quantity,
                $variant->available_stock
            );
        }

        $variant->increment('reserved_count', $quantity);
    }

    public function releaseStock(int $variantId, int $quantity): void
    {
        $variant = TicketVariant::lockForUpdate()->findOrFail($variantId);
        $variant->decrement('reserved_count', min($quantity, $variant->reserved_count));
    }

    public function confirmSale(int $variantId, int $quantity): void
    {
        $variant = TicketVariant::lockForUpdate()->findOrFail($variantId);
        $variant->decrement('reserved_count', $quantity);
        $variant->increment('sold_count', $quantity);
    }

    public function returnStock(int $variantId, int $quantity): void
    {
        $variant = TicketVariant::lockForUpdate()->findOrFail($variantId);
        $variant->decrement('sold_count', min($quantity, $variant->sold_count));
    }

    public function getTicketsForEvent(Event $event): Collection
    {
        return $event->tickets()
            ->with(['variants.eventDay'])
            ->orderBy('sort_order')
            ->get();
    }

    public function getTicketStats(Event $event): array
    {
        $tickets = $event->tickets()->with('variants')->get();

        $totalStock = 0;
        $totalSold = 0;
        $totalRevenue = 0;

        foreach ($tickets as $ticket) {
            foreach ($ticket->variants as $variant) {
                $totalStock += $variant->stock;
                $totalSold += $variant->sold_count;
                $totalRevenue += $variant->sold_count * $variant->price;
            }
        }

        return [
            'total_stock' => $totalStock,
            'total_sold' => $totalSold,
            'total_available' => $totalStock - $totalSold,
            'total_revenue' => $totalRevenue,
            'sell_through_rate' => $totalStock > 0 ? round(($totalSold / $totalStock) * 100, 1) : 0,
        ];
    }
}

======================================================================
FILE: app/Services/VoucherService.php (182 lines)
======================================================================
<?php

namespace App\Services;

use App\Enums\VoucherType;
use App\Exceptions\VoucherInvalidException;
use App\Models\Event;
use App\Models\Order;
use App\Models\User;
use App\Models\Voucher;
use App\Models\VoucherUsage;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class VoucherService
{
    public function create(array $data, ?User $createdBy = null): Voucher
    {
        return Voucher::create([
            'code' => $data['code'] ?? $this->generateCode(),
            'name' => $data['name'],
            'description' => $data['description'] ?? null,
            'type' => $data['type'] ?? VoucherType::FIXED,
            'value' => $data['value'],
            'min_purchase' => $data['min_purchase'] ?? null,
            'max_discount' => $data['max_discount'] ?? null,
            'usage_limit' => $data['usage_limit'] ?? null,
            'usage_limit_per_user' => $data['usage_limit_per_user'] ?? null,
            'event_id' => $data['event_id'] ?? null,
            'category_id' => $data['category_id'] ?? null,
            'starts_at' => $data['starts_at'] ?? null,
            'expires_at' => $data['expires_at'] ?? null,
            'is_active' => $data['is_active'] ?? true,
            'created_by' => $createdBy?->id,
        ]);
    }

    public function update(Voucher $voucher, array $data): Voucher
    {
        $voucher->update(collect($data)->only([
            'name', 'description', 'type', 'value', 'min_purchase', 'max_discount',
            'usage_limit', 'usage_limit_per_user', 'event_id', 'category_id',
            'starts_at', 'expires_at', 'is_active',
        ])->toArray());

        return $voucher->fresh();
    }

    public function delete(Voucher $voucher): bool
    {
        if ($voucher->usage_count > 0) {
            return false;
        }

        return $voucher->delete();
    }

    public function validate(string $code, User $user, Event $event, int $subtotal): Voucher
    {
        $voucher = Voucher::where('code', strtoupper($code))->first();

        if (!$voucher) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_NOT_FOUND);
        }

        if (!$voucher->is_active) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_INACTIVE);
        }

        if ($voucher->isExpired()) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_EXPIRED);
        }

        if ($voucher->starts_at && $voucher->starts_at->isFuture()) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_INACTIVE, 'Voucher belum aktif');
        }

        if ($voucher->hasReachedLimit()) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_USAGE_LIMIT);
        }

        if ($voucher->hasUserReachedLimit($user->id)) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_USER_LIMIT);
        }

        if (!$voucher->isApplicableToEvent($event)) {
            throw new VoucherInvalidException($code, VoucherInvalidException::REASON_NOT_APPLICABLE);
        }

        if (!$voucher->isApplicableToAmount($subtotal)) {
            throw new VoucherInvalidException(
                $code,
                VoucherInvalidException::REASON_MIN_PURCHASE,
                'Minimum pembelian ' . $voucher->formatted_min_purchase
            );
        }

        return $voucher;
    }

    public function calculateDiscount(Voucher $voucher, int $subtotal): int
    {
        return $voucher->calculateDiscount($subtotal);
    }

    public function recordUsage(Voucher $voucher, User $user, Order $order, int $discountAmount): VoucherUsage
    {
        $voucher->incrementUsage();

        return VoucherUsage::create([
            'voucher_id' => $voucher->id,
            'user_id' => $user->id,
            'order_id' => $order->id,
            'discount_amount' => $discountAmount,
        ]);
    }

    public function releaseUsage(Order $order): void
    {
        $usage = VoucherUsage::where('order_id', $order->id)->first();

        if ($usage) {
            $usage->voucher->decrementUsage();
            $usage->delete();
        }
    }

    public function getAll(array $filters = []): LengthAwarePaginator
    {
        $query = Voucher::query()->with(['event', 'category', 'createdBy']);

        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $query->where(function ($q) use ($search) {
                $q->where('code', 'ilike', "%{$search}%")
                    ->orWhere('name', 'ilike', "%{$search}%");
            });
        }

        if (isset($filters['is_active'])) {
            $query->where('is_active', $filters['is_active']);
        }

        if (!empty($filters['event_id'])) {
            $query->where('event_id', $filters['event_id']);
        }

        return $query->latest()->paginate(20);
    }

    public function getActiveVouchers(): Collection
    {
        return Voucher::query()
            ->active()
            ->available()
            ->get();
    }

    public function getVoucherStats(Voucher $voucher): array
    {
        $usages = $voucher->usages()->with('order')->get();

        return [
            'total_usage' => $voucher->usage_count,
            'remaining_usage' => $voucher->remaining_usage,
            'total_discount_given' => $usages->sum('discount_amount'),
            'unique_users' => $usages->pluck('user_id')->unique()->count(),
        ];
    }

    protected function generateCode(): string
    {
        do {
            $code = strtoupper(Str::random(8));
        } while (Voucher::where('code', $code)->exists());

        return $code;
    }
}

======================================================================
FILE: app/Services/Xendit/XenditClient.php (110 lines)
======================================================================
<?php

namespace App\Services\Xendit;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class XenditClient
{
    protected string $baseUrl;
    protected ?string $secretKey;

    public function __construct()
    {
        $this->baseUrl = config('xendit.base_url', 'https://api.xendit.co');
        $this->secretKey = config('xendit.secret_key');
    }

    public function isConfigured(): bool
    {
        return !empty($this->secretKey);
    }

    public function createInvoice(array $params): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured. Please set XENDIT_SECRET_KEY in .env');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->post("{$this->baseUrl}/v2/invoices", $params);

        if (!$response->successful()) {
            Log::channel('payment')->error('Xendit create invoice failed', [
                'status' => $response->status(),
                'body' => $response->json(),
            ]);

            throw new \Exception('Failed to create invoice: ' . ($response->json()['message'] ?? 'Unknown error'));
        }

        return $response->json();
    }

    public function getInvoice(string $invoiceId): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->get("{$this->baseUrl}/v2/invoices/{$invoiceId}");

        return $response->json();
    }

    public function expireInvoice(string $invoiceId): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->post("{$this->baseUrl}/invoices/{$invoiceId}/expire!");

        return $response->json();
    }

    public function getBalance(): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->get("{$this->baseUrl}/balance");

        return $response->json();
    }

    public function createDisbursement(array $params): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->post("{$this->baseUrl}/disbursements", $params);

        return $response->json();
    }

    public function getDisbursement(string $disbursementId): array
    {
        if (!$this->isConfigured()) {
            throw new \Exception('Xendit is not configured');
        }

        $response = Http::withBasicAuth($this->secretKey, '')
            ->get("{$this->baseUrl}/disbursements/{$disbursementId}");

        return $response->json();
    }

    public function verifyWebhookSignature(string $callbackToken, string $expectedToken): bool
    {
        return hash_equals($expectedToken, $callbackToken);
    }
}

======================================================================
FILE: app/Traits/HasSlug.php (42 lines)
======================================================================
<?php

namespace App\Traits;

use Illuminate\Support\Str;

trait HasSlug
{
    public static function bootHasSlug(): void
    {
        static::creating(function ($model) {
            if (empty($model->{$model->slugField()})) {
                $model->{$model->slugField()} = $model->generateUniqueSlug();
            }
        });
    }

    public function generateUniqueSlug(): string
    {
        $slug = Str::slug($this->{$this->slugSource()});
        $originalSlug = $slug;
        $count = 1;

        while (static::where($this->slugField(), $slug)->exists()) {
            $slug = "{$originalSlug}-{$count}";
            $count++;
        }

        return $slug;
    }

    protected function slugField(): string
    {
        return 'slug';
    }

    protected function slugSource(): string
    {
        return 'name';
    }
}

======================================================================
FILE: app/View/Components/AppLayout.php (15 lines)
======================================================================
<?php

namespace App\View\Components;

use Illuminate\View\Component;
use Illuminate\View\View;

class AppLayout extends Component
{
    public function render(): View
    {
        return view('layouts.app');
    }
}

======================================================================
FILE: app/View/Components/OrganizerLayout.php (15 lines)
======================================================================
<?php

namespace App\View\Components;

use Illuminate\View\Component;
use Illuminate\View\View;

class OrganizerLayout extends Component
{
    public function render(): View
    {
        return view('layouts.organizer');
    }
}

======================================================================
FILE: database/factories/UserFactory.php (45 lines)
======================================================================
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\User>
 */
class UserFactory extends Factory
{
    /**
     * The current password being used by the factory.
     */
    protected static ?string $password;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => static::$password ??= Hash::make('password'),
            'remember_token' => Str::random(10),
        ];
    }

    /**
     * Indicate that the model's email address should be unverified.
     */
    public function unverified(): static
    {
        return $this->state(fn (array $attributes) => [
            'email_verified_at' => null,
        ]);
    }
}

======================================================================
FILE: database/migrations/0001_01_01_000000_create_users_table.php (49 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->string('role', 20)->default('user'); // admin, organizer, user
            $table->string('phone', 20)->nullable();
            $table->string('avatar')->nullable();
            $table->rememberToken();
            $table->timestamps();

            $table->index('role');
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('sessions');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('users');
    }
};

======================================================================
FILE: database/migrations/0001_01_01_000001_create_cache_table.php (30 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('cache_locks');
        Schema::dropIfExists('cache');
    }
};

======================================================================
FILE: database/migrations/0001_01_01_000002_create_jobs_table.php (52 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('failed_jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('jobs');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000001_create_organizers_table.php (41 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('organizers', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->string('slug')->unique();
            $table->string('logo')->nullable();
            $table->string('banner')->nullable();
            $table->text('bio')->nullable();
            $table->string('website')->nullable();
            $table->string('email')->nullable();
            $table->string('phone', 20)->nullable();
            $table->text('address')->nullable();
            $table->string('city', 100)->nullable();
            $table->string('province', 100)->nullable();
            $table->string('bank_name', 100)->nullable();
            $table->string('bank_account_number', 50)->nullable();
            $table->string('bank_account_name')->nullable();
            $table->boolean('is_verified')->default(false);
            $table->timestamp('verified_at')->nullable();
            $table->timestamps();

            $table->index('is_verified');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('organizers');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000002_create_organizer_social_links_table.php (27 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('organizer_social_links', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organizer_id')->constrained()->cascadeOnDelete();
            $table->string('platform', 50); // instagram, twitter, facebook, youtube, tiktok, website
            $table->string('url', 500);
            $table->timestamps();

            $table->index('organizer_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('organizer_social_links');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000003_create_categories_table.php (31 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name', 100);
            $table->string('slug', 100)->unique();
            $table->text('description')->nullable();
            $table->string('icon', 100)->nullable();
            $table->string('color', 20)->nullable();
            $table->integer('sort_order')->default(0);
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index('is_active');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('categories');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000004_create_subcategories_table.php (30 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('subcategories', function (Blueprint $table) {
            $table->id();
            $table->foreignId('category_id')->constrained()->cascadeOnDelete();
            $table->string('name', 100);
            $table->string('slug', 100);
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->unique(['category_id', 'slug']);
            $table->index('category_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('subcategories');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000005_create_events_table.php (83 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('events', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organizer_id')->constrained();
            $table->foreignId('category_id')->constrained();

            // Basic Info
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('short_description', 500)->nullable();

            // Media
            $table->string('poster')->nullable();
            $table->string('banner')->nullable();
            $table->json('gallery')->nullable();

            // Date & Time
            $table->date('start_date');
            $table->date('end_date');
            $table->time('start_time')->nullable();
            $table->time('end_time')->nullable();
            $table->string('timezone', 50)->default('Asia/Jakarta');

            // Location
            $table->string('venue_name')->nullable();
            $table->text('venue_address')->nullable();
            $table->string('city', 100)->nullable();
            $table->string('province', 100)->nullable();
            $table->string('postal_code', 10)->nullable();
            $table->decimal('latitude', 10, 8)->nullable();
            $table->decimal('longitude', 11, 8)->nullable();
            $table->boolean('is_online')->default(false);
            $table->string('online_url')->nullable();

            // Status
            $table->string('status', 20)->default('draft'); // draft, pending_review, approved, published, cancelled, completed
            $table->boolean('is_featured')->default(false);
            $table->boolean('is_free')->default(false);

            // Pricing cache
            $table->integer('min_price')->default(0);
            $table->integer('max_price')->default(0);

            // Documents
            $table->string('proposal_file')->nullable();

            // Admin
            $table->text('admin_notes')->nullable();
            $table->text('rejection_reason')->nullable();
            $table->timestamp('published_at')->nullable();
            $table->timestamp('approved_at')->nullable();
            $table->foreignId('approved_by')->nullable()->constrained('users');

            // Stats
            $table->unsignedInteger('views_count')->default(0);

            $table->timestamps();

            // Indexes
            $table->index('status');
            $table->index('start_date');
            $table->index('city');
            $table->index('is_featured');
            $table->index(['status', 'start_date']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('events');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000006_create_event_subcategory_table.php (26 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('event_subcategory', function (Blueprint $table) {
            $table->id();
            $table->foreignId('event_id')->constrained()->cascadeOnDelete();
            $table->foreignId('subcategory_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['event_id', 'subcategory_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('event_subcategory');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000007_create_event_days_table.php (30 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('event_days', function (Blueprint $table) {
            $table->id();
            $table->foreignId('event_id')->constrained()->cascadeOnDelete();
            $table->date('date');
            $table->string('name')->nullable(); // e.g., "Day 1", "Saturday"
            $table->time('start_time')->nullable();
            $table->time('end_time')->nullable();
            $table->text('description')->nullable();
            $table->timestamps();

            $table->index(['event_id', 'date']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('event_days');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000008_create_tickets_table.php (33 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('tickets', function (Blueprint $table) {
            $table->id();
            $table->foreignId('event_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('type', 20)->default('regular'); // regular, vip, bundle, addon, free
            $table->json('benefits')->nullable(); // Array of benefit strings
            $table->unsignedInteger('max_per_order')->default(10);
            $table->unsignedInteger('sort_order')->default(0);
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index('event_id');
            $table->index('is_active');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('tickets');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000009_create_ticket_variants_table.php (39 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('ticket_variants', function (Blueprint $table) {
            $table->id();
            $table->foreignId('ticket_id')->constrained()->cascadeOnDelete();
            $table->foreignId('event_day_id')->nullable()->constrained()->nullOnDelete();
            $table->string('name')->nullable();
            $table->unsignedInteger('price')->default(0);
            $table->unsignedInteger('original_price')->nullable();
            $table->unsignedInteger('stock')->default(0);
            $table->unsignedInteger('sold_count')->default(0);
            $table->unsignedInteger('reserved_count')->default(0);
            $table->unsignedInteger('min_per_order')->default(1);
            $table->unsignedInteger('max_per_order')->nullable();
            $table->timestamp('sale_start_at')->nullable();
            $table->timestamp('sale_end_at')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index('ticket_id');
            $table->index('event_day_id');
            $table->index('is_active');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('ticket_variants');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000010_create_vouchers_table.php (42 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('vouchers', function (Blueprint $table) {
            $table->id();
            $table->string('code', 50)->unique();
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('type', 20)->default('fixed'); // fixed, percentage
            $table->unsignedInteger('value'); // Amount in rupiah or percentage
            $table->unsignedInteger('min_purchase')->nullable();
            $table->unsignedInteger('max_discount')->nullable(); // Max discount for percentage type
            $table->unsignedInteger('usage_limit')->nullable();
            $table->unsignedInteger('usage_count')->default(0);
            $table->unsignedInteger('usage_limit_per_user')->nullable();
            $table->foreignId('event_id')->nullable()->constrained()->nullOnDelete();
            $table->foreignId('category_id')->nullable()->constrained()->nullOnDelete();
            $table->timestamp('starts_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->boolean('is_active')->default(true);
            $table->foreignId('created_by')->nullable()->constrained('users')->nullOnDelete();
            $table->timestamps();

            $table->index('code');
            $table->index('is_active');
            $table->index('event_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('vouchers');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000011_create_orders_table.php (58 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('orders', function (Blueprint $table) {
            $table->id();
            $table->string('order_number', 20)->unique();
            $table->foreignId('user_id')->constrained();
            $table->foreignId('event_id')->constrained();
            $table->foreignId('voucher_id')->nullable()->constrained()->nullOnDelete();

            // Customer Info (snapshot)
            $table->string('customer_name');
            $table->string('customer_email');
            $table->string('customer_phone', 20)->nullable();

            // Pricing
            $table->unsignedInteger('subtotal')->default(0);
            $table->unsignedInteger('discount')->default(0);
            $table->unsignedInteger('platform_fee')->default(0);
            $table->unsignedInteger('payment_fee')->default(0);
            $table->unsignedInteger('total')->default(0);

            // Status
            $table->string('status', 20)->default('pending'); // pending, awaiting_payment, paid, completed, expired, cancelled, refunded
            $table->text('notes')->nullable();

            // Timestamps
            $table->timestamp('paid_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->timestamp('cancelled_at')->nullable();
            $table->text('cancellation_reason')->nullable();
            $table->timestamp('expires_at')->nullable();

            $table->timestamps();

            // Indexes
            $table->index('order_number');
            $table->index('user_id');
            $table->index('event_id');
            $table->index('status');
            $table->index('expires_at');
            $table->index(['status', 'expires_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('orders');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000012_create_order_items_table.php (37 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('order_items', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_id')->constrained()->cascadeOnDelete();
            $table->foreignId('ticket_id')->constrained();
            $table->foreignId('ticket_variant_id')->constrained();
            
            // Snapshot of ticket info at time of purchase
            $table->string('ticket_name');
            $table->string('variant_name')->nullable();
            
            $table->unsignedInteger('quantity');
            $table->unsignedInteger('unit_price');
            $table->unsignedInteger('subtotal');
            
            $table->timestamps();

            $table->index('order_id');
            $table->index('ticket_variant_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('order_items');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000013_create_payments_table.php (53 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('payments', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_id')->constrained()->cascadeOnDelete();
            
            // Xendit Data
            $table->string('xendit_invoice_id')->nullable()->unique();
            $table->string('xendit_invoice_url', 500)->nullable();
            $table->string('xendit_external_id')->nullable();
            
            // Payment Info
            $table->unsignedInteger('amount');
            $table->string('payment_method')->nullable(); // CREDIT_CARD, BANK_TRANSFER, EWALLET, QR_CODE
            $table->string('payment_channel')->nullable(); // BCA, BNI, OVO, DANA, etc
            
            // Status
            $table->string('status', 20)->default('pending'); // pending, paid, expired, failed, refunded
            
            // Timestamps
            $table->timestamp('paid_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            
            // Additional Xendit Data
            $table->unsignedInteger('paid_amount')->nullable();
            $table->unsignedInteger('adjusted_received_amount')->nullable();
            $table->unsignedInteger('fees_paid_amount')->nullable();
            
            // Raw Response
            $table->json('raw_response')->nullable();
            
            $table->timestamps();

            $table->index('xendit_invoice_id');
            $table->index('status');
            $table->index('order_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('payments');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000014_create_issued_tickets_table.php (45 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('issued_tickets', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_item_id')->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained();
            
            // Ticket Code
            $table->string('code', 20)->unique();
            $table->string('qr_code')->nullable(); // Path to QR code image if stored
            
            // Attendee Info
            $table->string('attendee_name')->nullable();
            $table->string('attendee_email')->nullable();
            $table->string('attendee_phone', 20)->nullable();
            
            // Check-in Status
            $table->boolean('is_used')->default(false);
            $table->timestamp('used_at')->nullable();
            $table->foreignId('used_by')->nullable()->constrained('users')->nullOnDelete();
            $table->text('check_in_notes')->nullable();
            
            $table->timestamps();

            $table->index('code');
            $table->index('order_item_id');
            $table->index('user_id');
            $table->index('is_used');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('issued_tickets');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000015_create_voucher_usages_table.php (30 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('voucher_usages', function (Blueprint $table) {
            $table->id();
            $table->foreignId('voucher_id')->constrained()->cascadeOnDelete();
            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
            $table->foreignId('order_id')->constrained()->cascadeOnDelete();
            $table->unsignedInteger('discount_amount');
            $table->timestamps();

            $table->index('voucher_id');
            $table->index('user_id');
            $table->unique(['voucher_id', 'order_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('voucher_usages');
    }
};

======================================================================
FILE: database/migrations/2024_01_01_000016_create_settlements_table.php (54 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('settlements', function (Blueprint $table) {
            $table->id();
            $table->foreignId('event_id')->constrained();
            $table->foreignId('organizer_id')->constrained();
            
            // Financial Summary
            $table->unsignedInteger('gross_amount')->default(0); // Total from ticket sales
            $table->unsignedInteger('platform_fee')->default(0); // Platform fee deducted
            $table->unsignedInteger('payment_fee_total')->default(0); // Total payment gateway fees
            $table->unsignedInteger('refund_amount')->default(0); // Total refunds
            $table->unsignedInteger('net_amount')->default(0); // Amount to transfer
            
            // Bank Details (snapshot from organizer)
            $table->string('bank_name', 100);
            $table->string('bank_account_number', 50);
            $table->string('bank_account_name');
            
            // Status
            $table->string('status', 20)->default('pending'); // pending, processing, transferred, failed
            
            // Transfer Info
            $table->string('transfer_reference')->nullable();
            $table->string('transfer_proof')->nullable();
            $table->timestamp('transferred_at')->nullable();
            $table->foreignId('processed_by')->nullable()->constrained('users')->nullOnDelete();
            
            // Notes
            $table->text('notes')->nullable();
            $table->text('admin_notes')->nullable();
            
            $table->timestamps();

            $table->index('event_id');
            $table->index('organizer_id');
            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('settlements');
    }
};

======================================================================
FILE: database/migrations/2026_01_13_000001_simplify_event_status.php (28 lines)
======================================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    public function up(): void
    {
        // Update existing events dengan status pending_review/approved ke published
        DB::table('events')
            ->whereIn('status', ['pending_review', 'approved'])
            ->update(['status' => 'published']);

        // Update rejected/cancelled ke draft
        DB::table('events')
            ->whereIn('status', ['cancelled'])
            ->update(['status' => 'draft']);
    }

    public function down(): void
    {
        // Tidak perlu rollback untuk MVP
    }
};

======================================================================
FILE: database/seeders/CategorySeeder.php (44 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Models\Category;
use Illuminate\Database\Seeder;

class CategorySeeder extends Seeder
{
    public function run(): void
    {
        $categories = [
            [
                'name' => 'Cosplay & Pop Culture',
                'slug' => 'cosplay-pop-culture',
                'description' => 'Event cosplay, anime expo, comic con, dan budaya pop lainnya',
                'icon' => 'sparkles',
                'color' => '#FF6B6B',
                'sort_order' => 1,
            ],
            [
                'name' => 'Music & Concert',
                'slug' => 'music-concert',
                'description' => 'Konser musik, festival, live performance, dan pertunjukan musik',
                'icon' => 'musical-note',
                'color' => '#4ECDC4',
                'sort_order' => 2,
            ],
            [
                'name' => 'Sports',
                'slug' => 'sports',
                'description' => 'Event olahraga, marathon, turnamen, dan kompetisi',
                'icon' => 'trophy',
                'color' => '#45B7D1',
                'sort_order' => 3,
            ],
        ];

        foreach ($categories as $category) {
            Category::create($category);
        }
    }
}

======================================================================
FILE: database/seeders/DatabaseSeeder.php (21 lines)
======================================================================
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            CategorySeeder::class,
            SubcategorySeeder::class,
            OrganizerSeeder::class,
            VoucherSeeder::class,
            EventSeeder::class,
        ]);
    }
}

======================================================================
FILE: database/seeders/EventSeeder.php (327 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Models\Event;
use App\Models\EventDay;
use App\Models\Organizer;
use App\Models\Category;
use App\Models\Ticket;
use App\Models\TicketVariant;
use App\Enums\EventStatus;
use Illuminate\Database\Seeder;
use Carbon\Carbon;

class EventSeeder extends Seeder
{
    public function run(): void
    {
        $organizers = Organizer::all();
        $categories = Category::all();

        if ($organizers->isEmpty() || $categories->isEmpty()) {
            $this->command->warn('Please run OrganizerSeeder and CategorySeeder first!');
            return;
        }

        $events = [
            // Cosplay & Pop Culture Events
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'cosplay-pop-culture')->first()->id,
                'title' => 'Indonesia Comic Con 2026',
                'description' => "Indonesia Comic Con kembali hadir dengan lineup yang lebih spektakuler!\n\nNikmati pengalaman terbaik dalam dunia pop culture dengan:\n- Guest Star internasional\n- Cosplay Competition dengan hadiah puluhan juta\n- Exclusive Merchandise\n- Meet & Greet dengan artis favorit\n- Gaming Tournament\n- Dan masih banyak lagi!\n\nJangan sampai ketinggalan event terbesar tahun ini!",
                'short_description' => 'Event pop culture terbesar di Indonesia dengan cosplay competition, guest star internasional, dan exclusive merchandise!',
                'start_date' => Carbon::now()->addDays(30),
                'end_date' => Carbon::now()->addDays(32),
                'start_time' => '10:00',
                'end_time' => '21:00',
                'venue_name' => 'Jakarta Convention Center',
                'venue_address' => 'Jl. Gatot Subroto No.1',
                'city' => 'Jakarta',
                'province' => 'DKI Jakarta',
                'is_featured' => true,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Daily Pass', 'description' => 'Akses 1 hari', 'price' => 150000, 'stock' => 1000],
                    ['name' => '3-Day Pass', 'description' => 'Akses 3 hari penuh', 'price' => 350000, 'stock' => 500],
                    ['name' => 'VIP Pass', 'description' => 'Akses VIP + Meet & Greet', 'price' => 750000, 'stock' => 100],
                ],
            ],
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'cosplay-pop-culture')->first()->id,
                'title' => 'Anime Festival Asia Jakarta',
                'description' => "AFA Jakarta 2026 menghadirkan pengalaman anime terlengkap!\n\nHighlights:\n- J-Pop Concert dengan artis Jepang\n- Anime Screening terbaru\n- Cosplay Runway\n- Doujin Market\n- Anime Quiz Competition\n- Workshops & Panels",
                'short_description' => 'Festival anime terbesar di Asia Tenggara hadir di Jakarta!',
                'start_date' => Carbon::now()->addDays(45),
                'end_date' => Carbon::now()->addDays(47),
                'start_time' => '10:00',
                'end_time' => '22:00',
                'venue_name' => 'ICE BSD',
                'venue_address' => 'Jl. BSD Grand Boulevard',
                'city' => 'Tangerang',
                'province' => 'Banten',
                'is_featured' => true,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Regular', 'description' => 'Akses area regular', 'price' => 200000, 'stock' => 2000],
                    ['name' => 'Premium', 'description' => 'Akses premium + exclusive merch', 'price' => 500000, 'stock' => 500],
                ],
            ],
            [
                'organizer_id' => $organizers->last()->id,
                'category_id' => $categories->where('slug', 'cosplay-pop-culture')->first()->id,
                'title' => 'Bandung Cosplay Party',
                'description' => "Cosplay party seru di kota Bandung!\n\nAcara meliputi:\n- Cosplay Competition\n- Coswalk\n- Photo Session\n- Games & Activities\n- Food Court\n\nTerbuka untuk semua umur!",
                'short_description' => 'Cosplay party seru dan meriah di Bandung!',
                'start_date' => Carbon::now()->addDays(14),
                'end_date' => Carbon::now()->addDays(14),
                'start_time' => '09:00',
                'end_time' => '18:00',
                'venue_name' => 'Trans Studio Mall Bandung',
                'venue_address' => 'Jl. Gatot Subroto No.289',
                'city' => 'Bandung',
                'province' => 'Jawa Barat',
                'is_featured' => false,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Reguler', 'description' => 'Tiket masuk standar', 'price' => 50000, 'stock' => 500],
                    ['name' => 'Cosplayer', 'description' => 'Tiket khusus cosplayer + changing room', 'price' => 75000, 'stock' => 200],
                ],
            ],

            // Music & Concert Events
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'music-concert')->first()->id,
                'title' => 'Java Jazz Festival 2026',
                'description' => "Java Jazz Festival kembali dengan lineup internasional!\n\nFeaturing:\n- International Jazz Artists\n- Local Jazz Heroes\n- Multiple Stages\n- Food & Beverage Area\n- After Party\n\n3 hari penuh musik jazz berkualitas!",
                'short_description' => 'Festival jazz terbesar di Indonesia dengan artis internasional!',
                'start_date' => Carbon::now()->addDays(60),
                'end_date' => Carbon::now()->addDays(62),
                'start_time' => '14:00',
                'end_time' => '23:59',
                'venue_name' => 'JIExpo Kemayoran',
                'venue_address' => 'Jl. Benyamin Suaeb',
                'city' => 'Jakarta',
                'province' => 'DKI Jakarta',
                'is_featured' => true,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Daily Pass', 'description' => 'Akses 1 hari', 'price' => 850000, 'stock' => 3000],
                    ['name' => '3-Day Pass', 'description' => 'Akses 3 hari', 'price' => 2000000, 'stock' => 1000],
                    ['name' => 'VIP 3-Day', 'description' => 'VIP access 3 hari + lounge', 'price' => 5000000, 'stock' => 200],
                ],
            ],
            [
                'organizer_id' => $organizers->last()->id,
                'category_id' => $categories->where('slug', 'music-concert')->first()->id,
                'title' => 'Indie Music Festival Yogyakarta',
                'description' => "Festival musik indie terbesar di Yogyakarta!\n\nLineup:\n- Band-band indie lokal & nasional\n- Acoustic Stage\n- Art Installation\n- Local Food Market\n- Clothing Brand Booth",
                'short_description' => 'Festival musik indie dengan suasana Jogja yang asik!',
                'start_date' => Carbon::now()->addDays(21),
                'end_date' => Carbon::now()->addDays(22),
                'start_time' => '15:00',
                'end_time' => '23:00',
                'venue_name' => 'Mandala Krida',
                'venue_address' => 'Jl. Kenari',
                'city' => 'Yogyakarta',
                'province' => 'DI Yogyakarta',
                'is_featured' => false,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Presale', 'description' => 'Harga early bird', 'price' => 100000, 'stock' => 500],
                    ['name' => 'Regular', 'description' => 'Harga normal', 'price' => 150000, 'stock' => 1500],
                ],
            ],
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'music-concert')->first()->id,
                'title' => 'Rock in Solo 2026',
                'description' => "Festival rock terbesar di Jawa Tengah!\n\nLineup:\n- Band rock legendaris Indonesia\n- New wave rock bands\n- Metal stage\n- Mosh pit area\n\nBersiaplah untuk headbang!",
                'short_description' => 'Festival rock dengan band-band legendaris Indonesia!',
                'start_date' => Carbon::now()->addDays(35),
                'end_date' => Carbon::now()->addDays(35),
                'start_time' => '16:00',
                'end_time' => '23:59',
                'venue_name' => 'Stadion Manahan',
                'venue_address' => 'Jl. Adi Sucipto',
                'city' => 'Solo',
                'province' => 'Jawa Tengah',
                'is_featured' => true,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Festival', 'description' => 'Standing area', 'price' => 250000, 'stock' => 5000],
                    ['name' => 'VIP', 'description' => 'VIP area + exclusive merch', 'price' => 750000, 'stock' => 500],
                ],
            ],

            // Sports Events
            [
                'organizer_id' => $organizers->last()->id,
                'category_id' => $categories->where('slug', 'sports')->first()->id,
                'title' => 'Jakarta Marathon 2026',
                'description' => "Jakarta Marathon mengajak kamu berlari melintasi kota Jakarta!\n\nKategori:\n- Full Marathon (42K)\n- Half Marathon (21K)\n- 10K Run\n- 5K Fun Run\n\nSetiap peserta mendapat:\n- Running jersey\n- Finisher medal\n- Snack pack\n- e-Certificate",
                'short_description' => 'Marathon tahunan terbesar di Jakarta dengan berbagai kategori!',
                'start_date' => Carbon::now()->addDays(50),
                'end_date' => Carbon::now()->addDays(50),
                'start_time' => '05:00',
                'end_time' => '12:00',
                'venue_name' => 'Monas',
                'venue_address' => 'Jl. Medan Merdeka',
                'city' => 'Jakarta',
                'province' => 'DKI Jakarta',
                'is_featured' => true,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => '5K Fun Run', 'description' => 'Kategori 5 kilometer', 'price' => 150000, 'stock' => 2000],
                    ['name' => '10K Run', 'description' => 'Kategori 10 kilometer', 'price' => 250000, 'stock' => 1500],
                    ['name' => 'Half Marathon', 'description' => 'Kategori 21 kilometer', 'price' => 400000, 'stock' => 1000],
                    ['name' => 'Full Marathon', 'description' => 'Kategori 42 kilometer', 'price' => 600000, 'stock' => 500],
                ],
            ],
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'sports')->first()->id,
                'title' => 'Bali Triathlon 2026',
                'description' => "Triathlon internasional di Pulau Dewata!\n\nKategori:\n- Olympic Distance\n- Sprint Distance\n- Super Sprint\n\nNikmati keindahan Bali sambil berkompetisi!",
                'short_description' => 'Event triathlon internasional di Bali yang menantang!',
                'start_date' => Carbon::now()->addDays(75),
                'end_date' => Carbon::now()->addDays(75),
                'start_time' => '06:00',
                'end_time' => '14:00',
                'venue_name' => 'Sanur Beach',
                'venue_address' => 'Jl. Pantai Sanur',
                'city' => 'Denpasar',
                'province' => 'Bali',
                'is_featured' => false,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Super Sprint', 'description' => 'Swim 400m, Bike 10K, Run 2.5K', 'price' => 500000, 'stock' => 300],
                    ['name' => 'Sprint', 'description' => 'Swim 750m, Bike 20K, Run 5K', 'price' => 750000, 'stock' => 200],
                    ['name' => 'Olympic', 'description' => 'Swim 1.5K, Bike 40K, Run 10K', 'price' => 1200000, 'stock' => 100],
                ],
            ],
            [
                'organizer_id' => $organizers->last()->id,
                'category_id' => $categories->where('slug', 'sports')->first()->id,
                'title' => 'Surabaya Basketball Tournament',
                'description' => "Turnamen basket 3x3 terbesar di Jawa Timur!\n\nKategori:\n- Open (umum)\n- U-18\n- U-15\n- Women\n\nTotal hadiah puluhan juta rupiah!",
                'short_description' => 'Turnamen basket 3x3 dengan berbagai kategori usia!',
                'start_date' => Carbon::now()->addDays(28),
                'end_date' => Carbon::now()->addDays(29),
                'start_time' => '08:00',
                'end_time' => '20:00',
                'venue_name' => 'Suncity Mall',
                'venue_address' => 'Jl. HR Muhammad',
                'city' => 'Surabaya',
                'province' => 'Jawa Timur',
                'is_featured' => false,
                'is_free' => false,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Team Registration', 'description' => 'Registrasi per tim (4 orang)', 'price' => 300000, 'stock' => 32],
                ],
            ],

            // Free Event
            [
                'organizer_id' => $organizers->first()->id,
                'category_id' => $categories->where('slug', 'cosplay-pop-culture')->first()->id,
                'title' => 'Free Cosplay Gathering Jakarta',
                'description' => "Gathering cosplay GRATIS untuk komunitas!\n\nAcara:\n- Photo session bersama\n- Games\n- Sharing session\n- Networking\n\nTerbuka untuk semua cosplayer dan pecinta anime!",
                'short_description' => 'Gathering cosplay gratis untuk komunitas Jakarta!',
                'start_date' => Carbon::now()->addDays(7),
                'end_date' => Carbon::now()->addDays(7),
                'start_time' => '13:00',
                'end_time' => '18:00',
                'venue_name' => 'Taman Menteng',
                'venue_address' => 'Jl. HOS Cokroaminoto',
                'city' => 'Jakarta',
                'province' => 'DKI Jakarta',
                'is_featured' => false,
                'is_free' => true,
                'status' => EventStatus::PUBLISHED,
                'published_at' => now(),
                'tickets' => [
                    ['name' => 'Free Entry', 'description' => 'Tiket masuk gratis', 'price' => 0, 'stock' => 200],
                ],
            ],
        ];

        foreach ($events as $eventData) {
            $tickets = $eventData['tickets'];
            unset($eventData['tickets']);

            // Create event
            $event = Event::create($eventData);

            // Create event days
            $startDate = Carbon::parse($eventData['start_date']);
            $endDate = Carbon::parse($eventData['end_date']);

            $dayNumber = 1;
            while ($startDate->lte($endDate)) {
                EventDay::create([
                    'event_id' => $event->id,
                    'name' => 'Day ' . $dayNumber,
                    'date' => $startDate->toDateString(),
                ]);
                $startDate->addDay();
                $dayNumber++;
            }

            // Create tickets with variants
            $sortOrder = 1;
            foreach ($tickets as $ticketData) {
                $ticket = Ticket::create([
                    'event_id' => $event->id,
                    'name' => $ticketData['name'],
                    'description' => $ticketData['description'],
                    // 'type' => 'paid', // â† HAPUS BARIS INI
                    'sort_order' => $sortOrder++,
                    'is_active' => true,
                ]);

                TicketVariant::create([
                    'ticket_id' => $ticket->id,
                    'name' => null,
                    'price' => $ticketData['price'],
                    'stock' => $ticketData['stock'],
                    'sold_count' => 0,
                    'reserved_count' => 0,
                    'min_per_order' => 1,
                    'max_per_order' => 5,
                    'is_active' => true,
                ]);
            }

            // Update price range
            $event->update([
                'min_price' => $event->lowest_price,
                'max_price' => $event->highest_price,
            ]);
        }

        $this->command->info('Created ' . count($events) . ' events with tickets!');
    }
}

======================================================================
FILE: database/seeders/OrganizerSeeder.php (75 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Models\Organizer;
use App\Models\OrganizerSocialLink;
use App\Models\User;
use Illuminate\Database\Seeder;

class OrganizerSeeder extends Seeder
{
    public function run(): void
    {
        $organizers = [
            [
                'email' => 'organizer@ngevent.id',
                'organizer' => [
                    'name' => 'Event Organizer Demo',
                    'slug' => 'event-organizer-demo',
                    'bio' => 'Professional event organizer with 10+ years experience in organizing various events across Indonesia.',
                    'city' => 'Jakarta',
                    'province' => 'DKI Jakarta',
                    'bank_name' => 'BCA',
                    'bank_account_number' => '1234567890',
                    'bank_account_name' => 'PT Event Organizer Demo',
                    'is_verified' => true,
                    'verified_at' => now(),
                ],
                'social_links' => [
                    ['platform' => 'instagram', 'url' => 'https://instagram.com/eventorganizerdemo'],
                    ['platform' => 'twitter', 'url' => 'https://twitter.com/eventorgdemo'],
                ],
            ],
            [
                'email' => 'music@ngevent.id',
                'organizer' => [
                    'name' => 'Music Festival Indonesia',
                    'slug' => 'music-festival-indonesia',
                    'bio' => 'Bringing the best music experiences to Indonesia since 2015. We organize concerts, festivals, and intimate gigs.',
                    'city' => 'Bandung',
                    'province' => 'Jawa Barat',
                    'bank_name' => 'Mandiri',
                    'bank_account_number' => '0987654321',
                    'bank_account_name' => 'PT Music Festival Indonesia',
                    'is_verified' => true,
                    'verified_at' => now(),
                ],
                'social_links' => [
                    ['platform' => 'instagram', 'url' => 'https://instagram.com/musicfestid'],
                    ['platform' => 'youtube', 'url' => 'https://youtube.com/@musicfestid'],
                    ['platform' => 'website', 'url' => 'https://musicfestival.id'],
                ],
            ],
        ];

        foreach ($organizers as $data) {
            $user = User::where('email', $data['email'])->first();

            if ($user) {
                $organizer = Organizer::create(array_merge(
                    ['user_id' => $user->id],
                    $data['organizer']
                ));

                foreach ($data['social_links'] as $link) {
                    OrganizerSocialLink::create(array_merge(
                        ['organizer_id' => $organizer->id],
                        $link
                    ));
                }
            }
        }
    }
}

======================================================================
FILE: database/seeders/SubcategorySeeder.php (49 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Models\Category;
use App\Models\Subcategory;
use Illuminate\Database\Seeder;
use Illuminate\Support\Str;

class SubcategorySeeder extends Seeder
{
    public function run(): void
    {
        $subcategories = [
            'cosplay-pop-culture' => [
                'Anime Expo', 'Comic Con', 'Cosplay Competition', 'Figure Exhibition',
                'Fan Meeting', 'Manga Festival', 'Gaming Convention', 'K-Pop Event',
                'J-Pop Event', 'Tokusatsu', 'Idol Festival', 'Art Exhibition',
            ],
            'music-concert' => [
                'Live Band', 'DJ Performance', 'Orchestra', 'Indie', 'Pop',
                'Rock', 'Jazz', 'EDM', 'Mini Gig', 'Music Festival',
                'Meet & Greet', 'VIP Access', 'All Ages', '17+', '21+',
                'Seating', 'Standing', 'Acoustic', 'Hip Hop', 'R&B',
            ],
            'sports' => [
                'Marathon', 'Fun Run', 'Tournament', 'Championship', 'Exhibition Match',
                'Esports', 'Fitness Event', 'Cycling', 'Swimming', 'Football',
                'Basketball', 'Badminton', 'Tennis', 'Volleyball', 'Triathlon',
                'Color Run', 'Night Run', 'Trail Run',
            ],
        ];

        foreach ($subcategories as $categorySlug => $subs) {
            $category = Category::where('slug', $categorySlug)->first();

            if ($category) {
                foreach ($subs as $name) {
                    Subcategory::create([
                        'category_id' => $category->id,
                        'name' => $name,
                        'slug' => Str::slug($name),
                    ]);
                }
            }
        }
    }
}

======================================================================
FILE: database/seeders/UserSeeder.php (53 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Enums\UserRole;
use App\Models\User;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Hash;

class UserSeeder extends Seeder
{
    public function run(): void
    {
        // Admin User
        User::create([
            'name' => 'Admin ngevent',
            'email' => 'admin@ngevent.id',
            'password' => Hash::make('password'),
            'role' => UserRole::ADMIN,
            'email_verified_at' => now(),
        ]);

        // Organizer Users
        User::create([
            'name' => 'Event Organizer Demo',
            'email' => 'organizer@ngevent.id',
            'password' => Hash::make('password'),
            'role' => UserRole::ORGANIZER,
            'email_verified_at' => now(),
        ]);

        User::create([
            'name' => 'Music Festival ID',
            'email' => 'music@ngevent.id',
            'password' => Hash::make('password'),
            'role' => UserRole::ORGANIZER,
            'email_verified_at' => now(),
        ]);

        // Regular Users
        User::create([
            'name' => 'John Doe',
            'email' => 'user@ngevent.id',
            'password' => Hash::make('password'),
            'role' => UserRole::USER,
            'email_verified_at' => now(),
        ]);

        // Create more random users for testing
        User::factory(20)->create();
    }
}

======================================================================
FILE: database/seeders/VoucherSeeder.php (69 lines)
======================================================================
<?php

namespace Database\Seeders;

use App\Enums\VoucherType;
use App\Models\User;
use App\Models\Voucher;
use Illuminate\Database\Seeder;

class VoucherSeeder extends Seeder
{
    public function run(): void
    {
        $admin = User::where('role', 'admin')->first();

        $vouchers = [
            [
                'code' => 'WELCOME10',
                'name' => 'Welcome Discount',
                'description' => 'Diskon 10% untuk pengguna baru',
                'type' => VoucherType::PERCENTAGE,
                'value' => 10,
                'max_discount' => 50000,
                'usage_limit' => 1000,
                'usage_limit_per_user' => 1,
                'expires_at' => now()->addMonths(3),
            ],
            [
                'code' => 'NGEVENT50K',
                'name' => 'Discount Rp 50.000',
                'description' => 'Potongan langsung Rp 50.000',
                'type' => VoucherType::FIXED,
                'value' => 50000,
                'min_purchase' => 200000,
                'usage_limit' => 500,
                'expires_at' => now()->addMonth(),
            ],
            [
                'code' => 'MUSIC25',
                'name' => 'Music Festival Discount',
                'description' => 'Diskon 25% untuk event musik',
                'type' => VoucherType::PERCENTAGE,
                'value' => 25,
                'max_discount' => 100000,
                'min_purchase' => 100000,
                'category_id' => 2, // Music & Concert
                'usage_limit' => 200,
                'expires_at' => now()->addWeeks(2),
            ],
            [
                'code' => 'FREESHIP',
                'name' => 'Free Service Fee',
                'description' => 'Gratis biaya layanan',
                'type' => VoucherType::FIXED,
                'value' => 5000,
                'usage_limit' => null, // Unlimited
                'expires_at' => now()->addYear(),
            ],
        ];

        foreach ($vouchers as $voucher) {
            Voucher::create(array_merge(
                ['created_by' => $admin?->id],
                $voucher
            ));
        }
    }
}
